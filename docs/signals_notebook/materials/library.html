<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>signals_notebook.materials.library API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>signals_notebook.materials.library</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cgi
import io
import json
import logging
import time
import zipfile
from datetime import datetime
from enum import Enum
from typing import Any, cast, List, Literal, Optional, Union

import requests
from pydantic import BaseModel, Field, PrivateAttr

from signals_notebook.api import SignalsNotebookApi
from signals_notebook.common_types import File, Links, MaterialType, MID, Response, ResponseData
from signals_notebook.materials.asset import Asset
from signals_notebook.materials.base_entity import BaseMaterialEntity
from signals_notebook.materials.batch import Batch
from signals_notebook.materials.field import AssetConfig, BatchConfig
from signals_notebook.utils.fs_handler import FSHandler

MAX_MATERIAL_FILE_SIZE = 52428800
EXPORT_ERROR_LIBRARY_EMPTY = &#39;Nothing to export.&#39;

log = logging.getLogger(__name__)


class MaterialImportRule(str, Enum):
    NO_DUPLICATED = &#39;NO_DUPLICATED&#39;
    TREAT_AS_UNIQUE = &#39;TREAT_AS_UNIQUE&#39;
    USE_MATCHES = &#39;USE_MATCHES&#39;


class ChangeBlameRecord(BaseModel):
    links: Links


class ChangeRecord(BaseModel):
    at: datetime = Field(allow_mutation=False)
    by: ChangeBlameRecord = Field(allow_mutation=False)

    class Config:
        validate_assignment = True


class _LibraryListData(BaseModel):
    id: str
    name: str
    digest: str
    edited: ChangeRecord
    created: ChangeRecord
    asset_config: AssetConfig = Field(alias=&#39;assets&#39;)
    batch_config: BatchConfig = Field(alias=&#39;batches&#39;)

    class Config:
        frozen = True


class LibraryListResponse(Response[_LibraryListData]):
    pass


class AssetResponse(Response[Asset]):
    pass


class BatchResponse(Response[Batch]):
    pass


class BatchAssetField(BaseModel):
    id: str
    value: Any


class BatchAssetAttribute(BaseModel):
    fields: List[BatchAssetField]


class BatchRequestData(BaseModel):
    type: str = MaterialType.BATCH
    attributes: BatchAssetAttribute


class DataRelationship(BaseModel):
    data: BatchRequestData


class AssetRelationship(BaseModel):
    batch: DataRelationship


class AssetRequestData(BaseModel):
    type: str = MaterialType.ASSET
    attributes: BatchAssetAttribute
    relationships: Optional[AssetRelationship] = None


class Library(BaseMaterialEntity):
    type: Literal[MaterialType.LIBRARY] = Field(allow_mutation=False, default=MaterialType.LIBRARY)
    _asset_config: Optional[AssetConfig] = PrivateAttr(default=None)
    _batch_config: Optional[BatchConfig] = PrivateAttr(default=None)

    class Config:
        validate_assignment = True

    def _load_configs(self) -&gt; None:
        # the only way to get config is to fetch all libraries
        log.debug(&#39;Loading asset and batch configs to %s for %s&#39;, self.__class__.__name__, self.eid)

        result = self._get_library_list_response()
        for item in result.data:
            data = cast(_LibraryListData, cast(ResponseData, item).body)
            if data.id == self.asset_type_id:
                self._asset_config = data.asset_config
                self._batch_config = data.batch_config
                return

    @property
    def asset_config(self) -&gt; AssetConfig:
        &#34;&#34;&#34;Get Asset config

        Returns:
            AssetConfig
        &#34;&#34;&#34;
        if self._asset_config:
            return self._asset_config

        self._load_configs()

        log.debug(&#39;Checking Asset Config for %s...&#39;, self.eid)
        if self._asset_config is None:
            log.warning(&#39;Asset Config for %s cannot be None&#39;, self.eid)
        assert self._asset_config is not None, f&#39;Asset Config for {self.eid} cannot be None&#39;
        return self._asset_config

    @asset_config.setter
    def asset_config(self, config: AssetConfig) -&gt; None:
        &#34;&#34;&#34;Set new AssetConfig

        Args:
            config: AssetConfig object

        Returns:

        &#34;&#34;&#34;
        self._asset_config = config

    @property
    def batch_config(self) -&gt; BatchConfig:
        &#34;&#34;&#34;Get Batch config

        Returns:
            BatchConfig
        &#34;&#34;&#34;
        if self._batch_config:
            return self._batch_config

        self._load_configs()
        log.debug(&#39;Checking Batch Config for %s...&#39;, self.eid)
        if self._batch_config is None:
            log.warning(&#39;Batch Config for %s cannot be None&#39;, self.eid)
        assert self._batch_config is not None, f&#39;Batch Config for {self.eid} cannot be None&#39;
        return self._batch_config

    @batch_config.setter
    def batch_config(self, config: BatchConfig) -&gt; None:
        &#34;&#34;&#34;Set Batch config

        Args:
            config: BatchConfig object

        Returns:

        &#34;&#34;&#34;
        self._batch_config = config

    @classmethod
    def _get_library_list_response(cls) -&gt; LibraryListResponse:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get Library List Response for %s&#39;, cls.__name__)

        response = api.call(
            method=&#39;GET&#39;,
            path=(cls._get_endpoint(), &#39;libraries&#39;),
        )

        return LibraryListResponse(**response.json())

    @classmethod
    def get_list(cls) -&gt; List[&#39;Library&#39;]:
        &#34;&#34;&#34;Get list of libraries

        Returns:
            list of Library objects
        &#34;&#34;&#34;
        result = cls._get_library_list_response()
        log.debug(&#39;Get List of Libraries for %s&#39;, cls.__name__)

        libraries: List[&#39;Library&#39;] = []
        for item in result.data:
            data = cast(_LibraryListData, cast(ResponseData, item).body)
            library = cls(
                asset_type_id=data.id,
                eid=MID(f&#39;{MaterialType.LIBRARY}:{data.id}&#39;),
                library_name=data.name,
                name=data.name,
                digest=data.digest.split(&#39;:&#39;)[0],
                created_at=data.created.at,
                edited_at=data.edited.at,
            )
            library.asset_config = data.asset_config
            library.batch_config = data.batch_config
            libraries.append(library)

        return libraries

    def get_asset(self, name: str) -&gt; Asset:
        &#34;&#34;&#34;Fetch asset from a material library by asset ID.

        Args:
            name: asset id

        Returns:
            Asset
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get Asset for %s with name: %s&#39;, self.eid, name)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.name, &#39;assets&#39;, &#39;id&#39;, name),
        )

        result = AssetResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def get_asset_batches(self, name: str) -&gt; List[Batch]:
        &#34;&#34;&#34;Fetch batches of a specified Asset.

        Args:
            name: asset id

        Returns:
            list of Batch objects
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get Asset of Batches for %s with name: %s&#39;, self.eid, name)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.name, &#39;assets&#39;, name, &#39;batches&#39;),
        )

        result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

        return [cast(ResponseData, item).body for item in result.data]

    def get_batch(self, name: str) -&gt; Batch:
        &#34;&#34;&#34;Fetch batch from a material library by batch ID.

        Args:
            name: batch id

        Returns:
            Batch
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get a single Batch for %s with name: %s&#39;, self.eid, name)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.name, &#39;batches&#39;, &#39;id&#39;, name),
        )

        result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def create_batch(self, asset_name: str, batch_fields: dict[str, Any]) -&gt; Batch:
        &#34;&#34;&#34;reate a new batch for designated asset.

        Args:
            asset_name: asset id
            batch_fields: fields of batch

        Returns:

        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        fields = []
        log.debug(&#39;Create Batch for %s with asset name: %s&#39;, self.eid, asset_name, extra={&#39;batch_fields&#39;: batch_fields})

        for field in self.batch_config.fields:
            if field.name in batch_fields:
                fields.append({&#39;id&#39;: field.id, &#39;value&#39;: field.to_internal_value(batch_fields[field.name])})

        request_data = BatchRequestData(type=&#39;batch&#39;, attributes=BatchAssetAttribute(fields=fields))

        response = api.call(
            method=&#39;POST&#39;,
            path=(self._get_endpoint(), self.library_name, &#39;assets&#39;, asset_name, &#39;batches&#39;),
            json={&#39;data&#39;: request_data.dict()},
        )

        result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def _process_asset_with_batch_fields(
        self, asset_with_batch_fields: dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]
    ) -&gt; AssetRequestData:
        request_fields = {}

        for material_instance in asset_with_batch_fields:
            request_instance_fields = []
            config: Union[AssetConfig, BatchConfig] = self.asset_config
            if material_instance == MaterialType.BATCH:
                config = self.batch_config
            for field in config.fields:
                if field.name in asset_with_batch_fields[material_instance]:
                    request_instance_fields.append(
                        {
                            &#39;id&#39;: field.id,
                            &#39;value&#39;: field.to_internal_value(asset_with_batch_fields[material_instance][field.name]),
                        }
                    )

            request_fields[material_instance] = request_instance_fields

        return AssetRequestData(
            type=MaterialType.ASSET,
            attributes=BatchAssetAttribute(fields=request_fields[MaterialType.ASSET]),
            relationships=AssetRelationship(
                batch=DataRelationship(
                    data=BatchRequestData(
                        type=MaterialType.BATCH,
                        attributes=BatchAssetAttribute(fields=request_fields[MaterialType.BATCH]),
                    )
                )
            ),
        )

    def create_asset_with_batches(
        self, asset_with_batch_fields: dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]
    ) -&gt; Asset:
        &#34;&#34;&#34;Create new asset with batches

        Args:
            asset_with_batch_fields: dictionary of asset and batch fields

        Returns:
            Asset
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Create Asset with existing Batches for %s&#39;, self.eid)

        request_data = self._process_asset_with_batch_fields(asset_with_batch_fields)

        response = api.call(
            method=&#39;POST&#39;, path=(self._get_endpoint(), self.library_name, &#39;assets&#39;), json={&#39;data&#39;: request_data.dict()}
        )

        result = AssetResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def _is_file_ready(self, report_id: str) -&gt; dict[str, Any]:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Check job status for: %s| %s&#39;, self.__class__.__name__, self.eid)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), &#39;bulkExport&#39;, &#39;reports&#39;, report_id),
        )
        response_attributes = response.json().get(&#39;data&#39;).get(&#39;attributes&#39;)
        status = response_attributes.get(&#39;status&#39;)
        error = response_attributes.get(&#39;error&#39;, None)

        result = {
            &#39;success&#39;: response.status_code == 200 and status == &#39;COMPLETED&#39;,
            &#39;error&#39;: error.get(&#39;description&#39;) if error else None,
        }

        return result

    def _download_file(self, file_id: str) -&gt; requests.Response:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get file content for: %s| %s&#39;, self.__class__.__name__, self.eid)

        return api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), &#39;bulkExport&#39;, &#39;download&#39;, file_id),
        )

    def get_content(self, timeout: int = 30, period: int = 5) -&gt; File:
        &#34;&#34;&#34;Get library content.
        Compounds/Reagents (SNB) will be exported to SD file, others will be exported to CSV file.

        Args:
            timeout: max available time(seconds) to get file
            period: each n seconds(default value=5) api call

        Returns:
            File
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get content for: %s| %s&#39;, self.__class__.__name__, self.eid)

        bulk_export_response = api.call(
            method=&#39;POST&#39;,
            path=(self._get_endpoint(), self.name, &#39;bulkExport&#39;),
        )

        file_id, report_id = bulk_export_response.json()[&#39;data&#39;][&#39;attributes&#39;].values()

        initial_time = time.time()

        response = None

        while time.time() - initial_time &lt; timeout:
            result = self._is_file_ready(report_id)
            if result[&#39;error&#39;] == EXPORT_ERROR_LIBRARY_EMPTY:
                raise FileNotFoundError(&#39;Library is empty&#39;)
            if result[&#39;success&#39;] and not result[&#39;error&#39;]:
                response = self._download_file(file_id)
                break
            else:
                time.sleep(period)

        if not response:
            raise TimeoutError(&#39;Time is over to get file&#39;)

        content_disposition = response.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
        _, params = cgi.parse_header(content_disposition)

        return File(
            name=params[&#39;filename&#39;], content=response.content, content_type=response.headers.get(&#39;content-type&#39;)
        )

    def _get_import_job_completed_response(self, job_id: str) -&gt; requests.Response:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Check job status for: %s| %s&#39;, self.__class__.__name__, self.eid)

        return api.call(method=&#39;GET&#39;, path=(self._get_endpoint(), &#39;bulkImport&#39;, &#39;jobs&#39;, job_id))

    def _import_materials(
        self,
        materials: Union[File, list[dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]]],
        rule: MaterialImportRule = MaterialImportRule.TREAT_AS_UNIQUE,
        import_type: Literal[&#39;json&#39;, &#39;zip&#39;] = &#39;json&#39;,
    ) -&gt; requests.Response:

        api = SignalsNotebookApi.get_default_api()

        if isinstance(materials, File):
            if materials.size &gt; MAX_MATERIAL_FILE_SIZE:
                raise ValueError(&#39;Available file size is 50Mb&#39;)

            return api.call(
                method=&#39;POST&#39;,
                path=(self._get_endpoint(), self.name, &#39;bulkImport&#39;),
                params={
                    &#39;rule&#39;: rule,
                    &#39;importType&#39;: import_type,
                },
                headers={
                    &#39;Content-Type&#39;: &#39;application/octet-stream&#39;,
                },
                data=materials.content,
            )

        request_body = [{&#39;data&#39;: self._process_asset_with_batch_fields(material).dict()} for material in materials]

        return api.call(
            method=&#39;POST&#39;,
            path=(self._get_endpoint(), self.name, &#39;bulkImport&#39;),
            params={
                &#39;rule&#39;: rule,
                &#39;importType&#39;: import_type,
            },
            json=request_body,
        )

    def bulk_import(  # type: ignore
        self,
        materials: Union[File, list[dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]]],
        rule: MaterialImportRule = MaterialImportRule.TREAT_AS_UNIQUE,
        import_type: Literal[&#39;json&#39;, &#39;zip&#39;] = &#39;json&#39;,
        timeout: int = 30,
        period: int = 5,
    ) -&gt; Optional[File]:
        &#34;&#34;&#34;Bulk import materials into a specified material library. Support import data from json or zip file.
        Zip file should contain the sdf file or csv file and attachments. T
        he column name in each records of sdf/csv file should be match the asset field name.
        In sdf file, it doesn&#39;t support character &#39;-&#39;, &#39;.&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;=&#39;, &#39;%&#39;, &#39; &#39;,
        please replace them to &#39;_&#39; in records.
        Max materials size: 50MB.

        Rules of import:
        &#39;TREAT_AS_UNIQUE&#39;, each item will be treated as a new asset. Selected by default.
        &#39;USE_MATCHES&#39;, server will check the item with uniqueness check, if same will import as a batch.
        &#39;NO_DUPLICATED&#39;, server will check the item with uniqueness check, duplicates are skipped and not imported.

        Args:
            materials: materials in zip or json format
            rule: rule of import
            import_type: import type: json or zip
            timeout: max available time(seconds) to get file
            period: each n seconds(default value=5) api call

        Returns:
            File or None
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()

        bulk_import_response = self._import_materials(materials, rule, import_type)

        job_id = bulk_import_response.json()[&#39;data&#39;][&#39;id&#39;]

        initial_time = time.time()

        response = False
        import_job_status = &#39;FAILED&#39;

        while time.time() - initial_time &lt; timeout:
            completed_import_response = self._get_import_job_completed_response(job_id)
            import_job_status = completed_import_response.json()[&#39;data&#39;][&#39;attributes&#39;][&#39;status&#39;]
            import_response_code = completed_import_response.status_code

            if import_response_code != 200 and import_job_status != &#39;COMPLETED&#39;:
                time.sleep(period)
            else:
                response = True
                log.debug(&#39;Library import is completed&#39;)
                break

        if not response and import_job_status == &#39;FAILED&#39;:
            log.debug(&#39;Time is over to import file&#39;)

            failure_report_reponse = api.call(
                method=&#39;GET&#39;,
                path=(self._get_endpoint(), &#39;bulkImport&#39;, &#39;jobs&#39;, job_id, &#39;failures&#39;),
                params={
                    &#39;filename&#39;: f&#39;{self.name}_failure_report&#39;,
                },
            )
            content_disposition = failure_report_reponse.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
            _, params = cgi.parse_header(content_disposition)

            return File(
                name=params[&#39;filename&#39;],
                content=failure_report_reponse.content,
                content_type=failure_report_reponse.headers.get(&#39;content-type&#39;),
            )

    def dump(self, base_path: str, fs_handler: FSHandler):
        metadata = {
            **{k: v for k, v in self.dict().items() if k in (&#39;library_name&#39;, &#39;asset_type_id&#39;, &#39;eid&#39;, &#39;name&#39;)},
        }
        try:
            content = self.get_content(timeout=60)
            metadata[&#39;file_name&#39;] = content.name
            file_name = content.name
            data = content.content
            fs_handler.write(fs_handler.join_path(base_path, self.eid, file_name), data)
        except FileNotFoundError:
            metadata[&#39;error&#39;] = &#39;Library is empty&#39;
        except TimeoutError:
            metadata[&#39;error&#39;] = &#39;Time is over to dump library&#39;

        fs_handler.write(fs_handler.join_path(base_path, self.eid, &#39;metadata.json&#39;), json.dumps(metadata))

    @staticmethod
    def _generate_zip(my_file):
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, &#39;w&#39;, zipfile.ZIP_DEFLATED, False) as zip_file:
            zip_file.writestr(f&#39;summary.{my_file.content_type}&#39;, my_file.content)

        return zip_buffer

    def load(self, path: str, fs_handler: FSHandler):
        metadata_path = fs_handler.join_path(path, &#39;metadata.json&#39;)
        metadata = json.loads(fs_handler.read(metadata_path))

        content_path = fs_handler.join_path(path, metadata[&#39;file_name&#39;])
        content_type = metadata[&#39;file_name&#39;].split(&#39;.&#39;)[-1]
        content = fs_handler.read(content_path)

        materials = File(content=content, name=&#39;test&#39;, content_type=content_type)

        zip_buffer = self._generate_zip(materials)

        self.bulk_import(
            File(name=&#39;test&#39;, content=zip_buffer.getvalue(), content_type=&#39;zip&#39;), import_type=&#39;zip&#39;, timeout=120
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="signals_notebook.materials.library.AssetRelationship"><code class="flex name class">
<span>class <span class="ident">AssetRelationship</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssetRelationship(BaseModel):
    batch: DataRelationship</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.AssetRelationship.batch"><code class="name">var <span class="ident">batch</span> : <a title="signals_notebook.materials.library.DataRelationship" href="#signals_notebook.materials.library.DataRelationship">DataRelationship</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.AssetRequestData"><code class="flex name class">
<span>class <span class="ident">AssetRequestData</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssetRequestData(BaseModel):
    type: str = MaterialType.ASSET
    attributes: BatchAssetAttribute
    relationships: Optional[AssetRelationship] = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.AssetRequestData.attributes"><code class="name">var <span class="ident">attributes</span> : <a title="signals_notebook.materials.library.BatchAssetAttribute" href="#signals_notebook.materials.library.BatchAssetAttribute">BatchAssetAttribute</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.AssetRequestData.relationships"><code class="name">var <span class="ident">relationships</span> : Optional[<a title="signals_notebook.materials.library.AssetRelationship" href="#signals_notebook.materials.library.AssetRelationship">AssetRelationship</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.AssetRequestData.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.AssetResponse"><code class="flex name class">
<span>class <span class="ident">AssetResponse</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssetResponse(Response[Asset]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.materials.library.Response[Asset]" href="#signals_notebook.materials.library.Response[Asset]">Response[Asset]</a></li>
<li><a title="signals_notebook.common_types.Response" href="../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.AssetResponse.data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[Asset], List[pydantic.generics.ResponseData[Asset]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.AssetResponse.links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.BatchAssetAttribute"><code class="flex name class">
<span>class <span class="ident">BatchAssetAttribute</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatchAssetAttribute(BaseModel):
    fields: List[BatchAssetField]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.BatchAssetAttribute.fields"><code class="name">var <span class="ident">fields</span> : List[<a title="signals_notebook.materials.library.BatchAssetField" href="#signals_notebook.materials.library.BatchAssetField">BatchAssetField</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.BatchAssetField"><code class="flex name class">
<span>class <span class="ident">BatchAssetField</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatchAssetField(BaseModel):
    id: str
    value: Any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.BatchAssetField.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.BatchAssetField.value"><code class="name">var <span class="ident">value</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.BatchRequestData"><code class="flex name class">
<span>class <span class="ident">BatchRequestData</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatchRequestData(BaseModel):
    type: str = MaterialType.BATCH
    attributes: BatchAssetAttribute</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.BatchRequestData.attributes"><code class="name">var <span class="ident">attributes</span> : <a title="signals_notebook.materials.library.BatchAssetAttribute" href="#signals_notebook.materials.library.BatchAssetAttribute">BatchAssetAttribute</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.BatchRequestData.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.BatchResponse"><code class="flex name class">
<span>class <span class="ident">BatchResponse</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatchResponse(Response[Batch]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.materials.asset.Response[Batch]" href="asset.html#signals_notebook.materials.asset.Response[Batch]">Response[Batch]</a></li>
<li><a title="signals_notebook.common_types.Response" href="../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.BatchResponse.data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[Batch], List[pydantic.generics.ResponseData[Batch]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.BatchResponse.links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.ChangeBlameRecord"><code class="flex name class">
<span>class <span class="ident">ChangeBlameRecord</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChangeBlameRecord(BaseModel):
    links: Links</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.ChangeBlameRecord.links"><code class="name">var <span class="ident">links</span> : <a title="signals_notebook.common_types.Links" href="../common_types.html#signals_notebook.common_types.Links">Links</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.ChangeRecord"><code class="flex name class">
<span>class <span class="ident">ChangeRecord</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChangeRecord(BaseModel):
    at: datetime = Field(allow_mutation=False)
    by: ChangeBlameRecord = Field(allow_mutation=False)

    class Config:
        validate_assignment = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.ChangeRecord.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.ChangeRecord.at"><code class="name">var <span class="ident">at</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.ChangeRecord.by"><code class="name">var <span class="ident">by</span> : <a title="signals_notebook.materials.library.ChangeBlameRecord" href="#signals_notebook.materials.library.ChangeBlameRecord">ChangeBlameRecord</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.DataRelationship"><code class="flex name class">
<span>class <span class="ident">DataRelationship</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataRelationship(BaseModel):
    data: BatchRequestData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.DataRelationship.data"><code class="name">var <span class="ident">data</span> : <a title="signals_notebook.materials.library.BatchRequestData" href="#signals_notebook.materials.library.BatchRequestData">BatchRequestData</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.Library"><code class="flex name class">
<span>class <span class="ident">Library</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p><a href="https://github.com/samuelcolvin/pydantic/issues/1577">https://github.com/samuelcolvin/pydantic/issues/1577</a>
Adds ability to use properties with setters</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Library(BaseMaterialEntity):
    type: Literal[MaterialType.LIBRARY] = Field(allow_mutation=False, default=MaterialType.LIBRARY)
    _asset_config: Optional[AssetConfig] = PrivateAttr(default=None)
    _batch_config: Optional[BatchConfig] = PrivateAttr(default=None)

    class Config:
        validate_assignment = True

    def _load_configs(self) -&gt; None:
        # the only way to get config is to fetch all libraries
        log.debug(&#39;Loading asset and batch configs to %s for %s&#39;, self.__class__.__name__, self.eid)

        result = self._get_library_list_response()
        for item in result.data:
            data = cast(_LibraryListData, cast(ResponseData, item).body)
            if data.id == self.asset_type_id:
                self._asset_config = data.asset_config
                self._batch_config = data.batch_config
                return

    @property
    def asset_config(self) -&gt; AssetConfig:
        &#34;&#34;&#34;Get Asset config

        Returns:
            AssetConfig
        &#34;&#34;&#34;
        if self._asset_config:
            return self._asset_config

        self._load_configs()

        log.debug(&#39;Checking Asset Config for %s...&#39;, self.eid)
        if self._asset_config is None:
            log.warning(&#39;Asset Config for %s cannot be None&#39;, self.eid)
        assert self._asset_config is not None, f&#39;Asset Config for {self.eid} cannot be None&#39;
        return self._asset_config

    @asset_config.setter
    def asset_config(self, config: AssetConfig) -&gt; None:
        &#34;&#34;&#34;Set new AssetConfig

        Args:
            config: AssetConfig object

        Returns:

        &#34;&#34;&#34;
        self._asset_config = config

    @property
    def batch_config(self) -&gt; BatchConfig:
        &#34;&#34;&#34;Get Batch config

        Returns:
            BatchConfig
        &#34;&#34;&#34;
        if self._batch_config:
            return self._batch_config

        self._load_configs()
        log.debug(&#39;Checking Batch Config for %s...&#39;, self.eid)
        if self._batch_config is None:
            log.warning(&#39;Batch Config for %s cannot be None&#39;, self.eid)
        assert self._batch_config is not None, f&#39;Batch Config for {self.eid} cannot be None&#39;
        return self._batch_config

    @batch_config.setter
    def batch_config(self, config: BatchConfig) -&gt; None:
        &#34;&#34;&#34;Set Batch config

        Args:
            config: BatchConfig object

        Returns:

        &#34;&#34;&#34;
        self._batch_config = config

    @classmethod
    def _get_library_list_response(cls) -&gt; LibraryListResponse:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get Library List Response for %s&#39;, cls.__name__)

        response = api.call(
            method=&#39;GET&#39;,
            path=(cls._get_endpoint(), &#39;libraries&#39;),
        )

        return LibraryListResponse(**response.json())

    @classmethod
    def get_list(cls) -&gt; List[&#39;Library&#39;]:
        &#34;&#34;&#34;Get list of libraries

        Returns:
            list of Library objects
        &#34;&#34;&#34;
        result = cls._get_library_list_response()
        log.debug(&#39;Get List of Libraries for %s&#39;, cls.__name__)

        libraries: List[&#39;Library&#39;] = []
        for item in result.data:
            data = cast(_LibraryListData, cast(ResponseData, item).body)
            library = cls(
                asset_type_id=data.id,
                eid=MID(f&#39;{MaterialType.LIBRARY}:{data.id}&#39;),
                library_name=data.name,
                name=data.name,
                digest=data.digest.split(&#39;:&#39;)[0],
                created_at=data.created.at,
                edited_at=data.edited.at,
            )
            library.asset_config = data.asset_config
            library.batch_config = data.batch_config
            libraries.append(library)

        return libraries

    def get_asset(self, name: str) -&gt; Asset:
        &#34;&#34;&#34;Fetch asset from a material library by asset ID.

        Args:
            name: asset id

        Returns:
            Asset
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get Asset for %s with name: %s&#39;, self.eid, name)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.name, &#39;assets&#39;, &#39;id&#39;, name),
        )

        result = AssetResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def get_asset_batches(self, name: str) -&gt; List[Batch]:
        &#34;&#34;&#34;Fetch batches of a specified Asset.

        Args:
            name: asset id

        Returns:
            list of Batch objects
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get Asset of Batches for %s with name: %s&#39;, self.eid, name)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.name, &#39;assets&#39;, name, &#39;batches&#39;),
        )

        result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

        return [cast(ResponseData, item).body for item in result.data]

    def get_batch(self, name: str) -&gt; Batch:
        &#34;&#34;&#34;Fetch batch from a material library by batch ID.

        Args:
            name: batch id

        Returns:
            Batch
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get a single Batch for %s with name: %s&#39;, self.eid, name)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.name, &#39;batches&#39;, &#39;id&#39;, name),
        )

        result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def create_batch(self, asset_name: str, batch_fields: dict[str, Any]) -&gt; Batch:
        &#34;&#34;&#34;reate a new batch for designated asset.

        Args:
            asset_name: asset id
            batch_fields: fields of batch

        Returns:

        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        fields = []
        log.debug(&#39;Create Batch for %s with asset name: %s&#39;, self.eid, asset_name, extra={&#39;batch_fields&#39;: batch_fields})

        for field in self.batch_config.fields:
            if field.name in batch_fields:
                fields.append({&#39;id&#39;: field.id, &#39;value&#39;: field.to_internal_value(batch_fields[field.name])})

        request_data = BatchRequestData(type=&#39;batch&#39;, attributes=BatchAssetAttribute(fields=fields))

        response = api.call(
            method=&#39;POST&#39;,
            path=(self._get_endpoint(), self.library_name, &#39;assets&#39;, asset_name, &#39;batches&#39;),
            json={&#39;data&#39;: request_data.dict()},
        )

        result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def _process_asset_with_batch_fields(
        self, asset_with_batch_fields: dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]
    ) -&gt; AssetRequestData:
        request_fields = {}

        for material_instance in asset_with_batch_fields:
            request_instance_fields = []
            config: Union[AssetConfig, BatchConfig] = self.asset_config
            if material_instance == MaterialType.BATCH:
                config = self.batch_config
            for field in config.fields:
                if field.name in asset_with_batch_fields[material_instance]:
                    request_instance_fields.append(
                        {
                            &#39;id&#39;: field.id,
                            &#39;value&#39;: field.to_internal_value(asset_with_batch_fields[material_instance][field.name]),
                        }
                    )

            request_fields[material_instance] = request_instance_fields

        return AssetRequestData(
            type=MaterialType.ASSET,
            attributes=BatchAssetAttribute(fields=request_fields[MaterialType.ASSET]),
            relationships=AssetRelationship(
                batch=DataRelationship(
                    data=BatchRequestData(
                        type=MaterialType.BATCH,
                        attributes=BatchAssetAttribute(fields=request_fields[MaterialType.BATCH]),
                    )
                )
            ),
        )

    def create_asset_with_batches(
        self, asset_with_batch_fields: dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]
    ) -&gt; Asset:
        &#34;&#34;&#34;Create new asset with batches

        Args:
            asset_with_batch_fields: dictionary of asset and batch fields

        Returns:
            Asset
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Create Asset with existing Batches for %s&#39;, self.eid)

        request_data = self._process_asset_with_batch_fields(asset_with_batch_fields)

        response = api.call(
            method=&#39;POST&#39;, path=(self._get_endpoint(), self.library_name, &#39;assets&#39;), json={&#39;data&#39;: request_data.dict()}
        )

        result = AssetResponse(_context={&#39;_library&#39;: self}, **response.json())

        return cast(ResponseData, result.data).body

    def _is_file_ready(self, report_id: str) -&gt; dict[str, Any]:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Check job status for: %s| %s&#39;, self.__class__.__name__, self.eid)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), &#39;bulkExport&#39;, &#39;reports&#39;, report_id),
        )
        response_attributes = response.json().get(&#39;data&#39;).get(&#39;attributes&#39;)
        status = response_attributes.get(&#39;status&#39;)
        error = response_attributes.get(&#39;error&#39;, None)

        result = {
            &#39;success&#39;: response.status_code == 200 and status == &#39;COMPLETED&#39;,
            &#39;error&#39;: error.get(&#39;description&#39;) if error else None,
        }

        return result

    def _download_file(self, file_id: str) -&gt; requests.Response:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get file content for: %s| %s&#39;, self.__class__.__name__, self.eid)

        return api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), &#39;bulkExport&#39;, &#39;download&#39;, file_id),
        )

    def get_content(self, timeout: int = 30, period: int = 5) -&gt; File:
        &#34;&#34;&#34;Get library content.
        Compounds/Reagents (SNB) will be exported to SD file, others will be exported to CSV file.

        Args:
            timeout: max available time(seconds) to get file
            period: each n seconds(default value=5) api call

        Returns:
            File
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get content for: %s| %s&#39;, self.__class__.__name__, self.eid)

        bulk_export_response = api.call(
            method=&#39;POST&#39;,
            path=(self._get_endpoint(), self.name, &#39;bulkExport&#39;),
        )

        file_id, report_id = bulk_export_response.json()[&#39;data&#39;][&#39;attributes&#39;].values()

        initial_time = time.time()

        response = None

        while time.time() - initial_time &lt; timeout:
            result = self._is_file_ready(report_id)
            if result[&#39;error&#39;] == EXPORT_ERROR_LIBRARY_EMPTY:
                raise FileNotFoundError(&#39;Library is empty&#39;)
            if result[&#39;success&#39;] and not result[&#39;error&#39;]:
                response = self._download_file(file_id)
                break
            else:
                time.sleep(period)

        if not response:
            raise TimeoutError(&#39;Time is over to get file&#39;)

        content_disposition = response.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
        _, params = cgi.parse_header(content_disposition)

        return File(
            name=params[&#39;filename&#39;], content=response.content, content_type=response.headers.get(&#39;content-type&#39;)
        )

    def _get_import_job_completed_response(self, job_id: str) -&gt; requests.Response:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Check job status for: %s| %s&#39;, self.__class__.__name__, self.eid)

        return api.call(method=&#39;GET&#39;, path=(self._get_endpoint(), &#39;bulkImport&#39;, &#39;jobs&#39;, job_id))

    def _import_materials(
        self,
        materials: Union[File, list[dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]]],
        rule: MaterialImportRule = MaterialImportRule.TREAT_AS_UNIQUE,
        import_type: Literal[&#39;json&#39;, &#39;zip&#39;] = &#39;json&#39;,
    ) -&gt; requests.Response:

        api = SignalsNotebookApi.get_default_api()

        if isinstance(materials, File):
            if materials.size &gt; MAX_MATERIAL_FILE_SIZE:
                raise ValueError(&#39;Available file size is 50Mb&#39;)

            return api.call(
                method=&#39;POST&#39;,
                path=(self._get_endpoint(), self.name, &#39;bulkImport&#39;),
                params={
                    &#39;rule&#39;: rule,
                    &#39;importType&#39;: import_type,
                },
                headers={
                    &#39;Content-Type&#39;: &#39;application/octet-stream&#39;,
                },
                data=materials.content,
            )

        request_body = [{&#39;data&#39;: self._process_asset_with_batch_fields(material).dict()} for material in materials]

        return api.call(
            method=&#39;POST&#39;,
            path=(self._get_endpoint(), self.name, &#39;bulkImport&#39;),
            params={
                &#39;rule&#39;: rule,
                &#39;importType&#39;: import_type,
            },
            json=request_body,
        )

    def bulk_import(  # type: ignore
        self,
        materials: Union[File, list[dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]]],
        rule: MaterialImportRule = MaterialImportRule.TREAT_AS_UNIQUE,
        import_type: Literal[&#39;json&#39;, &#39;zip&#39;] = &#39;json&#39;,
        timeout: int = 30,
        period: int = 5,
    ) -&gt; Optional[File]:
        &#34;&#34;&#34;Bulk import materials into a specified material library. Support import data from json or zip file.
        Zip file should contain the sdf file or csv file and attachments. T
        he column name in each records of sdf/csv file should be match the asset field name.
        In sdf file, it doesn&#39;t support character &#39;-&#39;, &#39;.&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;=&#39;, &#39;%&#39;, &#39; &#39;,
        please replace them to &#39;_&#39; in records.
        Max materials size: 50MB.

        Rules of import:
        &#39;TREAT_AS_UNIQUE&#39;, each item will be treated as a new asset. Selected by default.
        &#39;USE_MATCHES&#39;, server will check the item with uniqueness check, if same will import as a batch.
        &#39;NO_DUPLICATED&#39;, server will check the item with uniqueness check, duplicates are skipped and not imported.

        Args:
            materials: materials in zip or json format
            rule: rule of import
            import_type: import type: json or zip
            timeout: max available time(seconds) to get file
            period: each n seconds(default value=5) api call

        Returns:
            File or None
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()

        bulk_import_response = self._import_materials(materials, rule, import_type)

        job_id = bulk_import_response.json()[&#39;data&#39;][&#39;id&#39;]

        initial_time = time.time()

        response = False
        import_job_status = &#39;FAILED&#39;

        while time.time() - initial_time &lt; timeout:
            completed_import_response = self._get_import_job_completed_response(job_id)
            import_job_status = completed_import_response.json()[&#39;data&#39;][&#39;attributes&#39;][&#39;status&#39;]
            import_response_code = completed_import_response.status_code

            if import_response_code != 200 and import_job_status != &#39;COMPLETED&#39;:
                time.sleep(period)
            else:
                response = True
                log.debug(&#39;Library import is completed&#39;)
                break

        if not response and import_job_status == &#39;FAILED&#39;:
            log.debug(&#39;Time is over to import file&#39;)

            failure_report_reponse = api.call(
                method=&#39;GET&#39;,
                path=(self._get_endpoint(), &#39;bulkImport&#39;, &#39;jobs&#39;, job_id, &#39;failures&#39;),
                params={
                    &#39;filename&#39;: f&#39;{self.name}_failure_report&#39;,
                },
            )
            content_disposition = failure_report_reponse.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
            _, params = cgi.parse_header(content_disposition)

            return File(
                name=params[&#39;filename&#39;],
                content=failure_report_reponse.content,
                content_type=failure_report_reponse.headers.get(&#39;content-type&#39;),
            )

    def dump(self, base_path: str, fs_handler: FSHandler):
        metadata = {
            **{k: v for k, v in self.dict().items() if k in (&#39;library_name&#39;, &#39;asset_type_id&#39;, &#39;eid&#39;, &#39;name&#39;)},
        }
        try:
            content = self.get_content(timeout=60)
            metadata[&#39;file_name&#39;] = content.name
            file_name = content.name
            data = content.content
            fs_handler.write(fs_handler.join_path(base_path, self.eid, file_name), data)
        except FileNotFoundError:
            metadata[&#39;error&#39;] = &#39;Library is empty&#39;
        except TimeoutError:
            metadata[&#39;error&#39;] = &#39;Time is over to dump library&#39;

        fs_handler.write(fs_handler.join_path(base_path, self.eid, &#39;metadata.json&#39;), json.dumps(metadata))

    @staticmethod
    def _generate_zip(my_file):
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, &#39;w&#39;, zipfile.ZIP_DEFLATED, False) as zip_file:
            zip_file.writestr(f&#39;summary.{my_file.content_type}&#39;, my_file.content)

        return zip_buffer

    def load(self, path: str, fs_handler: FSHandler):
        metadata_path = fs_handler.join_path(path, &#39;metadata.json&#39;)
        metadata = json.loads(fs_handler.read(metadata_path))

        content_path = fs_handler.join_path(path, metadata[&#39;file_name&#39;])
        content_type = metadata[&#39;file_name&#39;].split(&#39;.&#39;)[-1]
        content = fs_handler.read(content_path)

        materials = File(content=content, name=&#39;test&#39;, content_type=content_type)

        zip_buffer = self._generate_zip(materials)

        self.bulk_import(
            File(name=&#39;test&#39;, content=zip_buffer.getvalue(), content_type=&#39;zip&#39;), import_type=&#39;zip&#39;, timeout=120
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.materials.base_entity.BaseMaterialEntity" href="base_entity.html#signals_notebook.materials.base_entity.BaseMaterialEntity">BaseMaterialEntity</a></li>
<li><a title="signals_notebook.base.PatchedModel" href="../base.html#signals_notebook.base.PatchedModel">PatchedModel</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.Library.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.Library.type"><code class="name">var <span class="ident">type</span> : Literal[<MaterialType.LIBRARY: 'assetType'>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="signals_notebook.materials.library.Library.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>) ‑> List[<a title="signals_notebook.materials.library.Library" href="#signals_notebook.materials.library.Library">Library</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of libraries</p>
<h2 id="returns">Returns</h2>
<p>list of Library objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_list(cls) -&gt; List[&#39;Library&#39;]:
    &#34;&#34;&#34;Get list of libraries

    Returns:
        list of Library objects
    &#34;&#34;&#34;
    result = cls._get_library_list_response()
    log.debug(&#39;Get List of Libraries for %s&#39;, cls.__name__)

    libraries: List[&#39;Library&#39;] = []
    for item in result.data:
        data = cast(_LibraryListData, cast(ResponseData, item).body)
        library = cls(
            asset_type_id=data.id,
            eid=MID(f&#39;{MaterialType.LIBRARY}:{data.id}&#39;),
            library_name=data.name,
            name=data.name,
            digest=data.digest.split(&#39;:&#39;)[0],
            created_at=data.created.at,
            edited_at=data.edited.at,
        )
        library.asset_config = data.asset_config
        library.batch_config = data.batch_config
        libraries.append(library)

    return libraries</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="signals_notebook.materials.library.Library.asset_config"><code class="name">var <span class="ident">asset_config</span> : <a title="signals_notebook.materials.field.AssetConfig" href="field.html#signals_notebook.materials.field.AssetConfig">AssetConfig</a></code></dt>
<dd>
<div class="desc"><p>Get Asset config</p>
<h2 id="returns">Returns</h2>
<p>AssetConfig</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def asset_config(self) -&gt; AssetConfig:
    &#34;&#34;&#34;Get Asset config

    Returns:
        AssetConfig
    &#34;&#34;&#34;
    if self._asset_config:
        return self._asset_config

    self._load_configs()

    log.debug(&#39;Checking Asset Config for %s...&#39;, self.eid)
    if self._asset_config is None:
        log.warning(&#39;Asset Config for %s cannot be None&#39;, self.eid)
    assert self._asset_config is not None, f&#39;Asset Config for {self.eid} cannot be None&#39;
    return self._asset_config</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.batch_config"><code class="name">var <span class="ident">batch_config</span> : <a title="signals_notebook.materials.field.BatchConfig" href="field.html#signals_notebook.materials.field.BatchConfig">BatchConfig</a></code></dt>
<dd>
<div class="desc"><p>Get Batch config</p>
<h2 id="returns">Returns</h2>
<p>BatchConfig</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def batch_config(self) -&gt; BatchConfig:
    &#34;&#34;&#34;Get Batch config

    Returns:
        BatchConfig
    &#34;&#34;&#34;
    if self._batch_config:
        return self._batch_config

    self._load_configs()
    log.debug(&#39;Checking Batch Config for %s...&#39;, self.eid)
    if self._batch_config is None:
        log.warning(&#39;Batch Config for %s cannot be None&#39;, self.eid)
    assert self._batch_config is not None, f&#39;Batch Config for {self.eid} cannot be None&#39;
    return self._batch_config</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="signals_notebook.materials.library.Library.bulk_import"><code class="name flex">
<span>def <span class="ident">bulk_import</span></span>(<span>self, materials: Union[<a title="signals_notebook.common_types.File" href="../common_types.html#signals_notebook.common_types.File">File</a>, list], rule: <a title="signals_notebook.materials.library.MaterialImportRule" href="#signals_notebook.materials.library.MaterialImportRule">MaterialImportRule</a> = MaterialImportRule.TREAT_AS_UNIQUE, import_type: Literal['json', 'zip'] = 'json', timeout: int = 30, period: int = 5) ‑> Optional[<a title="signals_notebook.common_types.File" href="../common_types.html#signals_notebook.common_types.File">File</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk import materials into a specified material library. Support import data from json or zip file.
Zip file should contain the sdf file or csv file and attachments. T
he column name in each records of sdf/csv file should be match the asset field name.
In sdf file, it doesn't support character '-', '.', '&lt;', '&gt;', '=', '%', ' ',
please replace them to '_' in records.
Max materials size: 50MB.</p>
<p>Rules of import:
'TREAT_AS_UNIQUE', each item will be treated as a new asset. Selected by default.
'USE_MATCHES', server will check the item with uniqueness check, if same will import as a batch.
'NO_DUPLICATED', server will check the item with uniqueness check, duplicates are skipped and not imported.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>materials</code></strong></dt>
<dd>materials in zip or json format</dd>
<dt><strong><code>rule</code></strong></dt>
<dd>rule of import</dd>
<dt><strong><code>import_type</code></strong></dt>
<dd>import type: json or zip</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>max available time(seconds) to get file</dd>
<dt><strong><code>period</code></strong></dt>
<dd>each n seconds(default value=5) api call</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>File or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_import(  # type: ignore
    self,
    materials: Union[File, list[dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]]],
    rule: MaterialImportRule = MaterialImportRule.TREAT_AS_UNIQUE,
    import_type: Literal[&#39;json&#39;, &#39;zip&#39;] = &#39;json&#39;,
    timeout: int = 30,
    period: int = 5,
) -&gt; Optional[File]:
    &#34;&#34;&#34;Bulk import materials into a specified material library. Support import data from json or zip file.
    Zip file should contain the sdf file or csv file and attachments. T
    he column name in each records of sdf/csv file should be match the asset field name.
    In sdf file, it doesn&#39;t support character &#39;-&#39;, &#39;.&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;=&#39;, &#39;%&#39;, &#39; &#39;,
    please replace them to &#39;_&#39; in records.
    Max materials size: 50MB.

    Rules of import:
    &#39;TREAT_AS_UNIQUE&#39;, each item will be treated as a new asset. Selected by default.
    &#39;USE_MATCHES&#39;, server will check the item with uniqueness check, if same will import as a batch.
    &#39;NO_DUPLICATED&#39;, server will check the item with uniqueness check, duplicates are skipped and not imported.

    Args:
        materials: materials in zip or json format
        rule: rule of import
        import_type: import type: json or zip
        timeout: max available time(seconds) to get file
        period: each n seconds(default value=5) api call

    Returns:
        File or None
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()

    bulk_import_response = self._import_materials(materials, rule, import_type)

    job_id = bulk_import_response.json()[&#39;data&#39;][&#39;id&#39;]

    initial_time = time.time()

    response = False
    import_job_status = &#39;FAILED&#39;

    while time.time() - initial_time &lt; timeout:
        completed_import_response = self._get_import_job_completed_response(job_id)
        import_job_status = completed_import_response.json()[&#39;data&#39;][&#39;attributes&#39;][&#39;status&#39;]
        import_response_code = completed_import_response.status_code

        if import_response_code != 200 and import_job_status != &#39;COMPLETED&#39;:
            time.sleep(period)
        else:
            response = True
            log.debug(&#39;Library import is completed&#39;)
            break

    if not response and import_job_status == &#39;FAILED&#39;:
        log.debug(&#39;Time is over to import file&#39;)

        failure_report_reponse = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), &#39;bulkImport&#39;, &#39;jobs&#39;, job_id, &#39;failures&#39;),
            params={
                &#39;filename&#39;: f&#39;{self.name}_failure_report&#39;,
            },
        )
        content_disposition = failure_report_reponse.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
        _, params = cgi.parse_header(content_disposition)

        return File(
            name=params[&#39;filename&#39;],
            content=failure_report_reponse.content,
            content_type=failure_report_reponse.headers.get(&#39;content-type&#39;),
        )</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.create_asset_with_batches"><code class="name flex">
<span>def <span class="ident">create_asset_with_batches</span></span>(<span>self, asset_with_batch_fields: dict) ‑> <a title="signals_notebook.materials.asset.Asset" href="asset.html#signals_notebook.materials.asset.Asset">Asset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create new asset with batches</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>asset_with_batch_fields</code></strong></dt>
<dd>dictionary of asset and batch fields</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Asset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_asset_with_batches(
    self, asset_with_batch_fields: dict[Literal[MaterialType.ASSET, MaterialType.BATCH], dict[str, Any]]
) -&gt; Asset:
    &#34;&#34;&#34;Create new asset with batches

    Args:
        asset_with_batch_fields: dictionary of asset and batch fields

    Returns:
        Asset
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()
    log.debug(&#39;Create Asset with existing Batches for %s&#39;, self.eid)

    request_data = self._process_asset_with_batch_fields(asset_with_batch_fields)

    response = api.call(
        method=&#39;POST&#39;, path=(self._get_endpoint(), self.library_name, &#39;assets&#39;), json={&#39;data&#39;: request_data.dict()}
    )

    result = AssetResponse(_context={&#39;_library&#39;: self}, **response.json())

    return cast(ResponseData, result.data).body</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.create_batch"><code class="name flex">
<span>def <span class="ident">create_batch</span></span>(<span>self, asset_name: str, batch_fields: dict) ‑> <a title="signals_notebook.materials.batch.Batch" href="batch.html#signals_notebook.materials.batch.Batch">Batch</a></span>
</code></dt>
<dd>
<div class="desc"><p>reate a new batch for designated asset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>asset_name</code></strong></dt>
<dd>asset id</dd>
<dt><strong><code>batch_fields</code></strong></dt>
<dd>fields of batch</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_batch(self, asset_name: str, batch_fields: dict[str, Any]) -&gt; Batch:
    &#34;&#34;&#34;reate a new batch for designated asset.

    Args:
        asset_name: asset id
        batch_fields: fields of batch

    Returns:

    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()
    fields = []
    log.debug(&#39;Create Batch for %s with asset name: %s&#39;, self.eid, asset_name, extra={&#39;batch_fields&#39;: batch_fields})

    for field in self.batch_config.fields:
        if field.name in batch_fields:
            fields.append({&#39;id&#39;: field.id, &#39;value&#39;: field.to_internal_value(batch_fields[field.name])})

    request_data = BatchRequestData(type=&#39;batch&#39;, attributes=BatchAssetAttribute(fields=fields))

    response = api.call(
        method=&#39;POST&#39;,
        path=(self._get_endpoint(), self.library_name, &#39;assets&#39;, asset_name, &#39;batches&#39;),
        json={&#39;data&#39;: request_data.dict()},
    )

    result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

    return cast(ResponseData, result.data).body</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self, base_path: str, fs_handler: <a title="signals_notebook.utils.fs_handler.FSHandler" href="../utils/fs_handler.html#signals_notebook.utils.fs_handler.FSHandler">FSHandler</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self, base_path: str, fs_handler: FSHandler):
    metadata = {
        **{k: v for k, v in self.dict().items() if k in (&#39;library_name&#39;, &#39;asset_type_id&#39;, &#39;eid&#39;, &#39;name&#39;)},
    }
    try:
        content = self.get_content(timeout=60)
        metadata[&#39;file_name&#39;] = content.name
        file_name = content.name
        data = content.content
        fs_handler.write(fs_handler.join_path(base_path, self.eid, file_name), data)
    except FileNotFoundError:
        metadata[&#39;error&#39;] = &#39;Library is empty&#39;
    except TimeoutError:
        metadata[&#39;error&#39;] = &#39;Time is over to dump library&#39;

    fs_handler.write(fs_handler.join_path(base_path, self.eid, &#39;metadata.json&#39;), json.dumps(metadata))</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.get_asset"><code class="name flex">
<span>def <span class="ident">get_asset</span></span>(<span>self, name: str) ‑> <a title="signals_notebook.materials.asset.Asset" href="asset.html#signals_notebook.materials.asset.Asset">Asset</a></span>
</code></dt>
<dd>
<div class="desc"><p>Fetch asset from a material library by asset ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>asset id</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Asset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_asset(self, name: str) -&gt; Asset:
    &#34;&#34;&#34;Fetch asset from a material library by asset ID.

    Args:
        name: asset id

    Returns:
        Asset
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()
    log.debug(&#39;Get Asset for %s with name: %s&#39;, self.eid, name)

    response = api.call(
        method=&#39;GET&#39;,
        path=(self._get_endpoint(), self.name, &#39;assets&#39;, &#39;id&#39;, name),
    )

    result = AssetResponse(_context={&#39;_library&#39;: self}, **response.json())

    return cast(ResponseData, result.data).body</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.get_asset_batches"><code class="name flex">
<span>def <span class="ident">get_asset_batches</span></span>(<span>self, name: str) ‑> List[<a title="signals_notebook.materials.batch.Batch" href="batch.html#signals_notebook.materials.batch.Batch">Batch</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch batches of a specified Asset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>asset id</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of Batch objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_asset_batches(self, name: str) -&gt; List[Batch]:
    &#34;&#34;&#34;Fetch batches of a specified Asset.

    Args:
        name: asset id

    Returns:
        list of Batch objects
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()
    log.debug(&#39;Get Asset of Batches for %s with name: %s&#39;, self.eid, name)

    response = api.call(
        method=&#39;GET&#39;,
        path=(self._get_endpoint(), self.name, &#39;assets&#39;, name, &#39;batches&#39;),
    )

    result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

    return [cast(ResponseData, item).body for item in result.data]</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.get_batch"><code class="name flex">
<span>def <span class="ident">get_batch</span></span>(<span>self, name: str) ‑> <a title="signals_notebook.materials.batch.Batch" href="batch.html#signals_notebook.materials.batch.Batch">Batch</a></span>
</code></dt>
<dd>
<div class="desc"><p>Fetch batch from a material library by batch ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>batch id</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Batch</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_batch(self, name: str) -&gt; Batch:
    &#34;&#34;&#34;Fetch batch from a material library by batch ID.

    Args:
        name: batch id

    Returns:
        Batch
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()
    log.debug(&#39;Get a single Batch for %s with name: %s&#39;, self.eid, name)

    response = api.call(
        method=&#39;GET&#39;,
        path=(self._get_endpoint(), self.name, &#39;batches&#39;, &#39;id&#39;, name),
    )

    result = BatchResponse(_context={&#39;_library&#39;: self}, **response.json())

    return cast(ResponseData, result.data).body</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.get_content"><code class="name flex">
<span>def <span class="ident">get_content</span></span>(<span>self, timeout: int = 30, period: int = 5) ‑> <a title="signals_notebook.common_types.File" href="../common_types.html#signals_notebook.common_types.File">File</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get library content.
Compounds/Reagents (SNB) will be exported to SD file, others will be exported to CSV file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>max available time(seconds) to get file</dd>
<dt><strong><code>period</code></strong></dt>
<dd>each n seconds(default value=5) api call</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>File</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content(self, timeout: int = 30, period: int = 5) -&gt; File:
    &#34;&#34;&#34;Get library content.
    Compounds/Reagents (SNB) will be exported to SD file, others will be exported to CSV file.

    Args:
        timeout: max available time(seconds) to get file
        period: each n seconds(default value=5) api call

    Returns:
        File
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()
    log.debug(&#39;Get content for: %s| %s&#39;, self.__class__.__name__, self.eid)

    bulk_export_response = api.call(
        method=&#39;POST&#39;,
        path=(self._get_endpoint(), self.name, &#39;bulkExport&#39;),
    )

    file_id, report_id = bulk_export_response.json()[&#39;data&#39;][&#39;attributes&#39;].values()

    initial_time = time.time()

    response = None

    while time.time() - initial_time &lt; timeout:
        result = self._is_file_ready(report_id)
        if result[&#39;error&#39;] == EXPORT_ERROR_LIBRARY_EMPTY:
            raise FileNotFoundError(&#39;Library is empty&#39;)
        if result[&#39;success&#39;] and not result[&#39;error&#39;]:
            response = self._download_file(file_id)
            break
        else:
            time.sleep(period)

    if not response:
        raise TimeoutError(&#39;Time is over to get file&#39;)

    content_disposition = response.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
    _, params = cgi.parse_header(content_disposition)

    return File(
        name=params[&#39;filename&#39;], content=response.content, content_type=response.headers.get(&#39;content-type&#39;)
    )</code></pre>
</details>
</dd>
<dt id="signals_notebook.materials.library.Library.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, path: str, fs_handler: <a title="signals_notebook.utils.fs_handler.FSHandler" href="../utils/fs_handler.html#signals_notebook.utils.fs_handler.FSHandler">FSHandler</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, path: str, fs_handler: FSHandler):
    metadata_path = fs_handler.join_path(path, &#39;metadata.json&#39;)
    metadata = json.loads(fs_handler.read(metadata_path))

    content_path = fs_handler.join_path(path, metadata[&#39;file_name&#39;])
    content_type = metadata[&#39;file_name&#39;].split(&#39;.&#39;)[-1]
    content = fs_handler.read(content_path)

    materials = File(content=content, name=&#39;test&#39;, content_type=content_type)

    zip_buffer = self._generate_zip(materials)

    self.bulk_import(
        File(name=&#39;test&#39;, content=zip_buffer.getvalue(), content_type=&#39;zip&#39;), import_type=&#39;zip&#39;, timeout=120
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.LibraryListResponse"><code class="flex name class">
<span>class <span class="ident">LibraryListResponse</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LibraryListResponse(Response[_LibraryListData]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.materials.library.Response[_LibraryListData]" href="#signals_notebook.materials.library.Response[_LibraryListData]">Response[_LibraryListData]</a></li>
<li><a title="signals_notebook.common_types.Response" href="../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.LibraryListResponse.data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[_LibraryListData], List[pydantic.generics.ResponseData[_LibraryListData]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.LibraryListResponse.links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.MaterialImportRule"><code class="flex name class">
<span>class <span class="ident">MaterialImportRule</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaterialImportRule(str, Enum):
    NO_DUPLICATED = &#39;NO_DUPLICATED&#39;
    TREAT_AS_UNIQUE = &#39;TREAT_AS_UNIQUE&#39;
    USE_MATCHES = &#39;USE_MATCHES&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.MaterialImportRule.NO_DUPLICATED"><code class="name">var <span class="ident">NO_DUPLICATED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.MaterialImportRule.TREAT_AS_UNIQUE"><code class="name">var <span class="ident">TREAT_AS_UNIQUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.MaterialImportRule.USE_MATCHES"><code class="name">var <span class="ident">USE_MATCHES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.Response[Asset]"><code class="flex name class">
<span>class <span class="ident">Response[Asset]</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.common_types.Response" href="../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="signals_notebook.materials.library.AssetResponse" href="#signals_notebook.materials.library.AssetResponse">AssetResponse</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.Response[Asset].Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.Response[Asset].data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[Asset], List[pydantic.generics.ResponseData[Asset]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.Response[Asset].links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.materials.library.Response[_LibraryListData]"><code class="flex name class">
<span>class <span class="ident">Response[_LibraryListData]</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.common_types.Response" href="../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="signals_notebook.materials.library.LibraryListResponse" href="#signals_notebook.materials.library.LibraryListResponse">LibraryListResponse</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.materials.library.Response[_LibraryListData].Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.Response[_LibraryListData].data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[_LibraryListData], List[pydantic.generics.ResponseData[_LibraryListData]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.materials.library.Response[_LibraryListData].links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="signals_notebook.materials" href="index.html">signals_notebook.materials</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="signals_notebook.materials.library.AssetRelationship" href="#signals_notebook.materials.library.AssetRelationship">AssetRelationship</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.AssetRelationship.batch" href="#signals_notebook.materials.library.AssetRelationship.batch">batch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.AssetRequestData" href="#signals_notebook.materials.library.AssetRequestData">AssetRequestData</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.AssetRequestData.attributes" href="#signals_notebook.materials.library.AssetRequestData.attributes">attributes</a></code></li>
<li><code><a title="signals_notebook.materials.library.AssetRequestData.relationships" href="#signals_notebook.materials.library.AssetRequestData.relationships">relationships</a></code></li>
<li><code><a title="signals_notebook.materials.library.AssetRequestData.type" href="#signals_notebook.materials.library.AssetRequestData.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.AssetResponse" href="#signals_notebook.materials.library.AssetResponse">AssetResponse</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.AssetResponse.data" href="#signals_notebook.materials.library.AssetResponse.data">data</a></code></li>
<li><code><a title="signals_notebook.materials.library.AssetResponse.links" href="#signals_notebook.materials.library.AssetResponse.links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.BatchAssetAttribute" href="#signals_notebook.materials.library.BatchAssetAttribute">BatchAssetAttribute</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.BatchAssetAttribute.fields" href="#signals_notebook.materials.library.BatchAssetAttribute.fields">fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.BatchAssetField" href="#signals_notebook.materials.library.BatchAssetField">BatchAssetField</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.BatchAssetField.id" href="#signals_notebook.materials.library.BatchAssetField.id">id</a></code></li>
<li><code><a title="signals_notebook.materials.library.BatchAssetField.value" href="#signals_notebook.materials.library.BatchAssetField.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.BatchRequestData" href="#signals_notebook.materials.library.BatchRequestData">BatchRequestData</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.BatchRequestData.attributes" href="#signals_notebook.materials.library.BatchRequestData.attributes">attributes</a></code></li>
<li><code><a title="signals_notebook.materials.library.BatchRequestData.type" href="#signals_notebook.materials.library.BatchRequestData.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.BatchResponse" href="#signals_notebook.materials.library.BatchResponse">BatchResponse</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.BatchResponse.data" href="#signals_notebook.materials.library.BatchResponse.data">data</a></code></li>
<li><code><a title="signals_notebook.materials.library.BatchResponse.links" href="#signals_notebook.materials.library.BatchResponse.links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.ChangeBlameRecord" href="#signals_notebook.materials.library.ChangeBlameRecord">ChangeBlameRecord</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.ChangeBlameRecord.links" href="#signals_notebook.materials.library.ChangeBlameRecord.links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.ChangeRecord" href="#signals_notebook.materials.library.ChangeRecord">ChangeRecord</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.ChangeRecord.Config" href="#signals_notebook.materials.library.ChangeRecord.Config">Config</a></code></li>
<li><code><a title="signals_notebook.materials.library.ChangeRecord.at" href="#signals_notebook.materials.library.ChangeRecord.at">at</a></code></li>
<li><code><a title="signals_notebook.materials.library.ChangeRecord.by" href="#signals_notebook.materials.library.ChangeRecord.by">by</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.DataRelationship" href="#signals_notebook.materials.library.DataRelationship">DataRelationship</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.DataRelationship.data" href="#signals_notebook.materials.library.DataRelationship.data">data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.Library" href="#signals_notebook.materials.library.Library">Library</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.Library.Config" href="#signals_notebook.materials.library.Library.Config">Config</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.asset_config" href="#signals_notebook.materials.library.Library.asset_config">asset_config</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.batch_config" href="#signals_notebook.materials.library.Library.batch_config">batch_config</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.bulk_import" href="#signals_notebook.materials.library.Library.bulk_import">bulk_import</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.create_asset_with_batches" href="#signals_notebook.materials.library.Library.create_asset_with_batches">create_asset_with_batches</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.create_batch" href="#signals_notebook.materials.library.Library.create_batch">create_batch</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.dump" href="#signals_notebook.materials.library.Library.dump">dump</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.get_asset" href="#signals_notebook.materials.library.Library.get_asset">get_asset</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.get_asset_batches" href="#signals_notebook.materials.library.Library.get_asset_batches">get_asset_batches</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.get_batch" href="#signals_notebook.materials.library.Library.get_batch">get_batch</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.get_content" href="#signals_notebook.materials.library.Library.get_content">get_content</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.get_list" href="#signals_notebook.materials.library.Library.get_list">get_list</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.load" href="#signals_notebook.materials.library.Library.load">load</a></code></li>
<li><code><a title="signals_notebook.materials.library.Library.type" href="#signals_notebook.materials.library.Library.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.LibraryListResponse" href="#signals_notebook.materials.library.LibraryListResponse">LibraryListResponse</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.LibraryListResponse.data" href="#signals_notebook.materials.library.LibraryListResponse.data">data</a></code></li>
<li><code><a title="signals_notebook.materials.library.LibraryListResponse.links" href="#signals_notebook.materials.library.LibraryListResponse.links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.MaterialImportRule" href="#signals_notebook.materials.library.MaterialImportRule">MaterialImportRule</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.MaterialImportRule.NO_DUPLICATED" href="#signals_notebook.materials.library.MaterialImportRule.NO_DUPLICATED">NO_DUPLICATED</a></code></li>
<li><code><a title="signals_notebook.materials.library.MaterialImportRule.TREAT_AS_UNIQUE" href="#signals_notebook.materials.library.MaterialImportRule.TREAT_AS_UNIQUE">TREAT_AS_UNIQUE</a></code></li>
<li><code><a title="signals_notebook.materials.library.MaterialImportRule.USE_MATCHES" href="#signals_notebook.materials.library.MaterialImportRule.USE_MATCHES">USE_MATCHES</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.Response[Asset]" href="#signals_notebook.materials.library.Response[Asset]">Response[Asset]</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.Response[Asset].Config" href="#signals_notebook.materials.library.Response[Asset].Config">Config</a></code></li>
<li><code><a title="signals_notebook.materials.library.Response[Asset].data" href="#signals_notebook.materials.library.Response[Asset].data">data</a></code></li>
<li><code><a title="signals_notebook.materials.library.Response[Asset].links" href="#signals_notebook.materials.library.Response[Asset].links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.materials.library.Response[_LibraryListData]" href="#signals_notebook.materials.library.Response[_LibraryListData]">Response[_LibraryListData]</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.materials.library.Response[_LibraryListData].Config" href="#signals_notebook.materials.library.Response[_LibraryListData].Config">Config</a></code></li>
<li><code><a title="signals_notebook.materials.library.Response[_LibraryListData].data" href="#signals_notebook.materials.library.Response[_LibraryListData].data">data</a></code></li>
<li><code><a title="signals_notebook.materials.library.Response[_LibraryListData].links" href="#signals_notebook.materials.library.Response[_LibraryListData].links">links</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>