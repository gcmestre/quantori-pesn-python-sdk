<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>signals_notebook.entities.tables.table API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>signals_notebook.entities.tables.table</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cgi
import json
import logging
from enum import Enum
from typing import Any, cast, Dict, List, Literal, Union
from uuid import UUID

import pandas as pd
from pydantic import Field, PrivateAttr

from signals_notebook.api import SignalsNotebookApi
from signals_notebook.common_types import DataList, EntityType, File, Response, ResponseData
from signals_notebook.entities import Entity, EntityStore
from signals_notebook.entities.container import Container
from signals_notebook.entities.tables.cell import Cell, CellContentDict, ColumnDefinitions, GenericColumnDefinition
from signals_notebook.entities.tables.row import ChangeRowRequest, Row
from signals_notebook.jinja_env import env
from signals_notebook.utils import FSHandler

log = logging.getLogger(__name__)


class TableDataResponse(Response[Row]):
    pass


class ColumnDefinitionsResponse(Response[ColumnDefinitions]):
    pass


class ChangeTableDataRequest(DataList[ChangeRowRequest]):
    pass


class Table(Entity):
    class ContentType(str, Enum):
        JSON = &#39;application/json&#39;
        CSV = &#39;text/csv&#39;

    type: Literal[EntityType.GRID] = Field(allow_mutation=False)
    _rows: List[Row] = PrivateAttr(default=[])
    _rows_by_id: Dict[UUID, Row] = PrivateAttr(default={})
    _template_name = &#39;table.html&#39;

    @classmethod
    def _get_entity_type(cls) -&gt; EntityType:
        return EntityType.GRID

    @classmethod
    def _get_adt_endpoint(cls) -&gt; str:
        return &#39;adt&#39;

    def _reload_data(self) -&gt; None:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Reloading data in Table: %s...&#39;, self.eid)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_adt_endpoint(), self.eid),
            params={
                &#39;value&#39;: &#39;normalized&#39;,
            },
        )

        result = TableDataResponse(**response.json())

        self._rows = []
        self._rows_by_id = {}
        for item in result.data:
            row = cast(Row, cast(ResponseData, item).body)
            assert row.id

            self._rows.append(row)
            self._rows_by_id[row.id] = row
        log.debug(&#39;Data in Table: %s were reloaded&#39;, self.eid)

    def get_column_definitions_list(self) -&gt; List[GenericColumnDefinition]:
        &#34;&#34;&#34;Fetch column definitions

        Returns:
            List[GenericColumnDefinition]
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()

        response = api.call(method=&#39;GET&#39;, path=(self._get_adt_endpoint(), self.eid, &#39;_column&#39;))

        result = ColumnDefinitionsResponse(**response.json())

        return cast(ResponseData, result.data).body.columns

    def get_column_definitions_map(self) -&gt; Dict[str, GenericColumnDefinition]:
        &#34;&#34;&#34;Get column definitions as a dictionary

        Returns:
            Dict[str, GenericColumnDefinition]
        &#34;&#34;&#34;
        column_definitions = self.get_column_definitions_list()
        column_definitions_map: Dict[str, GenericColumnDefinition] = {}

        for column_definition in column_definitions:
            column_definitions_map[str(column_definition.key)] = column_definition
            column_definitions_map[column_definition.title] = column_definition

        return column_definitions_map

    def as_dataframe(self, use_labels: bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get as data table

        Args:
            use_labels: use cells names

        Returns:
            pd.DataFrame
        &#34;&#34;&#34;
        if not self._rows:
            self._reload_data()

        data = []
        index = []
        for row in self._rows:
            index.append(row.id)
            data.append(row.get_values(use_labels))

        return pd.DataFrame(data=data, index=index)

    def as_raw_data(self, use_labels: bool = True) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Get as a list of dictionaries

        Args:
            use_labels: use cels names

        Returns:

        &#34;&#34;&#34;
        if not self._rows:
            self._reload_data()

        data = []
        for row in self._rows:
            data.append(row.get_values(use_labels))

        return data

    def __getitem__(self, index: Union[int, str, UUID]) -&gt; Row:
        if not self._rows:
            self._reload_data()

        if isinstance(index, int):
            return self._rows[index]

        if isinstance(index, str):
            return self._rows_by_id[UUID(index)]

        if isinstance(index, UUID):
            return self._rows_by_id[index]

        raise IndexError(&#39;Invalid index&#39;)

    def __iter__(self):
        if not self._rows:
            self._reload_data()

        return self._rows.__iter__()

    def delete_row_by_id(self, row_id: Union[str, UUID], digest: str = None, force: bool = True) -&gt; None:
        &#34;&#34;&#34;

        Args:
            row_id: id of the row
            digest: Indicate digest of entity. It is used to avoid conflict while concurrent editing.
            If the parameter &#39;force&#39; is true, this parameter is optional.
            If the parameter &#39;force&#39; is false, this parameter is required.
            force: Force to update properties without digest check.

        Returns:

        &#34;&#34;&#34;
        if isinstance(row_id, UUID):
            _row_id = row_id.hex
        else:
            _row_id = row_id

        api = SignalsNotebookApi.get_default_api()

        api.call(
            method=&#39;DELETE&#39;,
            path=(self._get_adt_endpoint(), self.eid, _row_id),
            params={
                &#39;digest&#39;: digest,
                &#39;force&#39;: json.dumps(force),
            },
        )

        log.debug(&#39;Row %s was deleted&#39;, row_id)
        self._reload_data()

    def add_row(self, data: Dict[str, CellContentDict]) -&gt; None:
        &#34;&#34;&#34;Add row in the table

        Args:
            data: Cells to add in the row

        Returns:

        &#34;&#34;&#34;
        column_definitions_map = self.get_column_definitions_map()

        prepared_data: List[Dict[str, Any]] = []
        for key, value in data.items():
            column_definition = column_definitions_map.get(key)
            if not column_definition:
                continue

            prepared_data.append(
                {
                    &#39;key&#39;: column_definition.key,
                    &#39;type&#39;: column_definition.type,
                    &#39;name&#39;: column_definition.title,
                    &#39;content&#39;: value,
                }
            )

        row = Row(cells=prepared_data)
        self._rows.append(row)
        log.debug(&#39;Row: %s was added to Table&#39;, row)

    def save(self, force: bool = True) -&gt; None:
        &#34;&#34;&#34;Save all changes in the table

        Args:
            force: Force to update properties without digest check.

        Returns:

        &#34;&#34;&#34;
        super().save(force)

        row_requests: List[ChangeRowRequest] = []
        for row in self._rows:
            row_request = row.get_change_request()
            if row_request:
                row_requests.append(row_request)

        if not row_requests:
            return

        request = ChangeTableDataRequest(data=row_requests)
        api = SignalsNotebookApi.get_default_api()

        api.call(
            method=&#39;PATCH&#39;,
            path=(self._get_adt_endpoint(), self.eid),
            params={
                &#39;digest&#39;: None if force else self.digest,
                &#39;force&#39;: json.dumps(force),
            },
            data=request.json(exclude_none=True, by_alias=True),
        )

        self._reload_data()

    def get(self, value: Union[str, UUID], default: Any = None) -&gt; Union[Row, Any]:
        &#34;&#34;&#34;Get Row

        Args:
            value: name of id of Row
            default: default value if it doens&#39;t exist

        Returns:
            Union[Row, Any]
        &#34;&#34;&#34;
        try:
            return self[value]
        except KeyError:
            log.debug(&#39;KeyError were caught. Default value returned&#39;)
            return default

    def get_content(self, content_type: str = ContentType.CSV.value) -&gt; File:
        &#34;&#34;&#34;Get Table content

        Args:
            content_type: Export resource format

        Returns:

        &#34;&#34;&#34;
        self.ContentType(content_type)
        if content_type == self.ContentType.JSON.value:
            rows = []
            for item in self:
                row = {}
                for cell in item:
                    row[cell.name] = cell.content.dict()
                rows.append(row)
            return File(
                name=f&#39;{self.name}.json&#39;,
                content=json.dumps({&#39;data&#39;: rows}, default=str).encode(&#39;utf-8&#39;),
                content_type=content_type,
            )

        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get content for: %s| %s&#39;, self.__class__.__name__, self.eid)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.eid, &#39;export&#39;),
            params={
                &#39;format&#39;: None,
            },
        )

        content_disposition = response.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
        _, params = cgi.parse_header(content_disposition)

        return File(
            name=params[&#39;filename&#39;],
            content=response.content,
            content_type=response.headers.get(&#39;content-type&#39;),
        )

    @classmethod
    def create(
        cls,
        *,
        container: Container,
        name: str,
        content: List[Dict[str, CellContentDict]] = None,
        template: str = None,
        digest: str = None,
        force: bool = True,
    ) -&gt; Entity:
        &#34;&#34;&#34;Create Table Entity

        Args:
            container: Container where create new Table
            name: file name
            content: Table content
            template: template for table creation
            digest: Indicate digest of entity. It is used to avoid conflict while concurrent editing.
            force: Force to post attachment

        Returns:
            Table
        &#34;&#34;&#34;
        log.debug(&#39;Create Table: %s...&#39;, cls.__name__)
        if template:
            api = SignalsNotebookApi.get_default_api()
            request = {
                &#39;data&#39;: {
                    &#39;type&#39;: EntityType.GRID,
                    &#39;attributes&#39;: {&#39;name&#39;: name},
                    &#39;relationships&#39;: {
                        &#39;ancestors&#39;: {&#39;data&#39;: [{&#39;type&#39;: EntityType.EXPERIMENT, &#39;id&#39;: container.eid}]},
                        &#39;template&#39;: {&#39;data&#39;: {&#39;type&#39;: EntityType.GRID, &#39;id&#39;: template}},
                    },
                }
            }

            response = api.call(
                method=&#39;POST&#39;,
                path=(cls._get_endpoint(),),
                params={
                    &#39;digest&#39;: digest,
                    &#39;force&#39;: json.dumps(force),
                },
                json=request,
            )
            result = TableResponse(**response.json())
            table = cast(ResponseData, result.data).body
            log.debug(&#39;Entity: %s was created.&#39;, cls.__name__)
            if content:
                for row in content:
                    table.add_row(row)
                table.save()
            return table

        log.debug(&#39;There is no needful template. Table will be uploaded as *.csv File...&#39;)
        log.debug(&#39;Create table: %s with name: %s in Container: %s&#39;, cls.__name__, name, container.eid)
        return container.add_child(
            name=name,
            content=json.dumps({&#39;data&#39;: content}, default=str).encode(&#39;utf-8&#39;),
            content_type=cls.ContentType.JSON,
            force=force,
        )

    def get_html(self) -&gt; str:
        &#34;&#34;&#34;Get in HTML format

        Returns:
            Rendered template as a string
        &#34;&#34;&#34;

        rows = []
        column_definitions = self.get_column_definitions_list()

        table_head = []
        for column_definition in column_definitions:
            table_head.append(column_definition.title)

        for row in self:
            reformatted_row = {}

            for column_definition in column_definitions:
                cell = cast(Row, row).get(column_definition.key, None)
                cell = cast(Cell, cell)
                reformatted_row[column_definition.title] = &#39;&#39; if cell is None else (cell.display or cell.value)

            rows.append(reformatted_row)

        template = env.get_template(self._template_name)
        log.info(&#39;Html template for %s:%s has been rendered.&#39;, self.__class__.__name__, self.eid)

        return template.render(name=self.name, table_head=table_head, rows=rows)

    def dump(self, base_path: str, fs_handler: FSHandler) -&gt; None:  # type: ignore[override]
        &#34;&#34;&#34;Dump Table entity

        Args:
            base_path: content path where create dump
            fs_handler: FSHandler

        Returns:

        &#34;&#34;&#34;
        log.debug(&#39;Dumping table: %s with name: %s...&#39;, self.eid, self.name)

        content = self.get_content(content_type=self.ContentType.JSON)
        column_definitions = self.get_column_definitions_list()

        metadata = {
            &#39;file_name&#39;: content.name,
            &#39;content_type&#39;: content.content_type,
            &#39;columns&#39;: [item.title for item in column_definitions],
            **{k: v for k, v in self.dict().items() if k in (&#39;name&#39;, &#39;description&#39;, &#39;eid&#39;)},
        }
        fs_handler.write(fs_handler.join_path(base_path, self.eid, &#39;metadata.json&#39;), json.dumps(metadata, default=str))
        file_name = content.name
        data = content.content
        fs_handler.write(fs_handler.join_path(base_path, self.eid, file_name), data)
        log.debug(&#39;Table: %s was dumped successfully&#39;, self.eid, self.name)

    @classmethod
    def load(cls, path: str, fs_handler: FSHandler, parent: Container) -&gt; None:  # type: ignore[override]
        &#34;&#34;&#34;Load Table entity

        Args:
            path: content path
            fs_handler: FSHandler
            parent: Container where load Table entity

        Returns:

        &#34;&#34;&#34;
        log.debug(&#39;Loading table from dump...&#39;)
        metadata_path = fs_handler.join_path(path, &#39;metadata.json&#39;)
        metadata = json.loads(fs_handler.read(metadata_path))
        content_path = fs_handler.join_path(path, metadata[&#39;file_name&#39;])
        content_bytes = fs_handler.read(content_path)
        content = json.loads(content_bytes)
        rows = content[&#39;data&#39;]
        column_definitions = metadata.get(&#39;columns&#39;)
        templates = EntityStore.get_list(
            include_types=[EntityType.GRID], include_options=[EntityStore.IncludeOptions.TEMPLATE]
        )

        file_creation = True
        for item in templates:
            template = cast(&#39;Table&#39;, item)
            template_column_definitions = template.get_column_definitions_list()
            template_columns = [item.title for item in template_column_definitions]
            if set(template_columns) == set(column_definitions):
                file_creation = False
                cls.create(
                    container=parent,
                    name=metadata[&#39;name&#39;],
                    template=template.eid,
                    content=rows,
                )
                break

        if file_creation:
            cls.create(container=parent, name=metadata[&#39;name&#39;], content=rows, force=True)
        log.debug(&#39;Table was loaded to Container: %s&#39;, parent.eid)

    @classmethod
    def dump_templates(cls, base_path: str, fs_handler: FSHandler) -&gt; None:
        &#34;&#34;&#34;Dump Table templates

        Args:
            base_path: content path where create templates dump
            fs_handler: FSHandler

        Returns:

        &#34;&#34;&#34;
        from signals_notebook.entities import EntityStore

        entity_type = cls._get_entity_type()

        templates = EntityStore.get_list(
            include_types=[entity_type], include_options=[EntityStore.IncludeOptions.TEMPLATE]
        )

        try:
            for item in templates:
                template = cast(&#39;Table&#39;, item)
                content = template.get_content(content_type=cls.ContentType.JSON)
                column_definitions = template.get_column_definitions_list()
                metadata = {
                    &#39;file_name&#39;: content.name,
                    &#39;content_type&#39;: content.content_type,
                    &#39;columns&#39;: [item.title for item in column_definitions],
                    **{k: v for k, v in template.dict().items() if k in (&#39;name&#39;, &#39;description&#39;, &#39;eid&#39;)},
                }
                fs_handler.write(
                    fs_handler.join_path(base_path, &#39;templates&#39;, entity_type, f&#39;metadata_{template.name}.json&#39;),
                    json.dumps(metadata),
                )
        except TypeError:
            pass


class TableResponse(Response[Table]):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="signals_notebook.entities.tables.table.ChangeTableDataRequest"><code class="flex name class">
<span>class <span class="ident">ChangeTableDataRequest</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChangeTableDataRequest(DataList[ChangeRowRequest]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.DataList[ChangeRowRequest]" href="#signals_notebook.entities.tables.table.DataList[ChangeRowRequest]">DataList[ChangeRowRequest]</a></li>
<li><a title="signals_notebook.common_types.DataList" href="../../common_types.html#signals_notebook.common_types.DataList">DataList</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.ChangeTableDataRequest.data"><code class="name">var <span class="ident">data</span> : List[<a title="signals_notebook.entities.tables.row.ChangeRowRequest" href="row.html#signals_notebook.entities.tables.row.ChangeRowRequest">ChangeRowRequest</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.ColumnDefinitionsResponse"><code class="flex name class">
<span>class <span class="ident">ColumnDefinitionsResponse</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnDefinitionsResponse(Response[ColumnDefinitions]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.Response[ColumnDefinitions]" href="#signals_notebook.entities.tables.table.Response[ColumnDefinitions]">Response[ColumnDefinitions]</a></li>
<li><a title="signals_notebook.common_types.Response" href="../../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.ColumnDefinitionsResponse.data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[ColumnDefinitions], List[pydantic.generics.ResponseData[ColumnDefinitions]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.ColumnDefinitionsResponse.links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.DataList[ChangeRowRequest]"><code class="flex name class">
<span>class <span class="ident">DataList[ChangeRowRequest]</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.common_types.DataList" href="../../common_types.html#signals_notebook.common_types.DataList">DataList</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.ChangeTableDataRequest" href="#signals_notebook.entities.tables.table.ChangeTableDataRequest">ChangeTableDataRequest</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.DataList[ChangeRowRequest].Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.DataList[ChangeRowRequest].data"><code class="name">var <span class="ident">data</span> : List[<a title="signals_notebook.entities.tables.row.ChangeRowRequest" href="row.html#signals_notebook.entities.tables.row.ChangeRowRequest">ChangeRowRequest</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[ColumnDefinitions]"><code class="flex name class">
<span>class <span class="ident">Response[ColumnDefinitions]</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.common_types.Response" href="../../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.ColumnDefinitionsResponse" href="#signals_notebook.entities.tables.table.ColumnDefinitionsResponse">ColumnDefinitionsResponse</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.Response[ColumnDefinitions].Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[ColumnDefinitions].data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[ColumnDefinitions], List[pydantic.generics.ResponseData[ColumnDefinitions]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[ColumnDefinitions].links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[Row]"><code class="flex name class">
<span>class <span class="ident">Response[Row]</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.common_types.Response" href="../../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.TableDataResponse" href="#signals_notebook.entities.tables.table.TableDataResponse">TableDataResponse</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.Response[Row].Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[Row].data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[Row], List[pydantic.generics.ResponseData[Row]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[Row].links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[Table]"><code class="flex name class">
<span>class <span class="ident">Response[Table]</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.common_types.Response" href="../../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.TableResponse" href="#signals_notebook.entities.tables.table.TableResponse">TableResponse</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.Response[Table].Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[Table].data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[<a title="signals_notebook.entities.tables.table.Table" href="#signals_notebook.entities.tables.table.Table">Table</a>], List[pydantic.generics.ResponseData[<a title="signals_notebook.entities.tables.table.Table" href="#signals_notebook.entities.tables.table.Table">Table</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Response[Table].links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table(Entity):
    class ContentType(str, Enum):
        JSON = &#39;application/json&#39;
        CSV = &#39;text/csv&#39;

    type: Literal[EntityType.GRID] = Field(allow_mutation=False)
    _rows: List[Row] = PrivateAttr(default=[])
    _rows_by_id: Dict[UUID, Row] = PrivateAttr(default={})
    _template_name = &#39;table.html&#39;

    @classmethod
    def _get_entity_type(cls) -&gt; EntityType:
        return EntityType.GRID

    @classmethod
    def _get_adt_endpoint(cls) -&gt; str:
        return &#39;adt&#39;

    def _reload_data(self) -&gt; None:
        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Reloading data in Table: %s...&#39;, self.eid)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_adt_endpoint(), self.eid),
            params={
                &#39;value&#39;: &#39;normalized&#39;,
            },
        )

        result = TableDataResponse(**response.json())

        self._rows = []
        self._rows_by_id = {}
        for item in result.data:
            row = cast(Row, cast(ResponseData, item).body)
            assert row.id

            self._rows.append(row)
            self._rows_by_id[row.id] = row
        log.debug(&#39;Data in Table: %s were reloaded&#39;, self.eid)

    def get_column_definitions_list(self) -&gt; List[GenericColumnDefinition]:
        &#34;&#34;&#34;Fetch column definitions

        Returns:
            List[GenericColumnDefinition]
        &#34;&#34;&#34;
        api = SignalsNotebookApi.get_default_api()

        response = api.call(method=&#39;GET&#39;, path=(self._get_adt_endpoint(), self.eid, &#39;_column&#39;))

        result = ColumnDefinitionsResponse(**response.json())

        return cast(ResponseData, result.data).body.columns

    def get_column_definitions_map(self) -&gt; Dict[str, GenericColumnDefinition]:
        &#34;&#34;&#34;Get column definitions as a dictionary

        Returns:
            Dict[str, GenericColumnDefinition]
        &#34;&#34;&#34;
        column_definitions = self.get_column_definitions_list()
        column_definitions_map: Dict[str, GenericColumnDefinition] = {}

        for column_definition in column_definitions:
            column_definitions_map[str(column_definition.key)] = column_definition
            column_definitions_map[column_definition.title] = column_definition

        return column_definitions_map

    def as_dataframe(self, use_labels: bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get as data table

        Args:
            use_labels: use cells names

        Returns:
            pd.DataFrame
        &#34;&#34;&#34;
        if not self._rows:
            self._reload_data()

        data = []
        index = []
        for row in self._rows:
            index.append(row.id)
            data.append(row.get_values(use_labels))

        return pd.DataFrame(data=data, index=index)

    def as_raw_data(self, use_labels: bool = True) -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;Get as a list of dictionaries

        Args:
            use_labels: use cels names

        Returns:

        &#34;&#34;&#34;
        if not self._rows:
            self._reload_data()

        data = []
        for row in self._rows:
            data.append(row.get_values(use_labels))

        return data

    def __getitem__(self, index: Union[int, str, UUID]) -&gt; Row:
        if not self._rows:
            self._reload_data()

        if isinstance(index, int):
            return self._rows[index]

        if isinstance(index, str):
            return self._rows_by_id[UUID(index)]

        if isinstance(index, UUID):
            return self._rows_by_id[index]

        raise IndexError(&#39;Invalid index&#39;)

    def __iter__(self):
        if not self._rows:
            self._reload_data()

        return self._rows.__iter__()

    def delete_row_by_id(self, row_id: Union[str, UUID], digest: str = None, force: bool = True) -&gt; None:
        &#34;&#34;&#34;

        Args:
            row_id: id of the row
            digest: Indicate digest of entity. It is used to avoid conflict while concurrent editing.
            If the parameter &#39;force&#39; is true, this parameter is optional.
            If the parameter &#39;force&#39; is false, this parameter is required.
            force: Force to update properties without digest check.

        Returns:

        &#34;&#34;&#34;
        if isinstance(row_id, UUID):
            _row_id = row_id.hex
        else:
            _row_id = row_id

        api = SignalsNotebookApi.get_default_api()

        api.call(
            method=&#39;DELETE&#39;,
            path=(self._get_adt_endpoint(), self.eid, _row_id),
            params={
                &#39;digest&#39;: digest,
                &#39;force&#39;: json.dumps(force),
            },
        )

        log.debug(&#39;Row %s was deleted&#39;, row_id)
        self._reload_data()

    def add_row(self, data: Dict[str, CellContentDict]) -&gt; None:
        &#34;&#34;&#34;Add row in the table

        Args:
            data: Cells to add in the row

        Returns:

        &#34;&#34;&#34;
        column_definitions_map = self.get_column_definitions_map()

        prepared_data: List[Dict[str, Any]] = []
        for key, value in data.items():
            column_definition = column_definitions_map.get(key)
            if not column_definition:
                continue

            prepared_data.append(
                {
                    &#39;key&#39;: column_definition.key,
                    &#39;type&#39;: column_definition.type,
                    &#39;name&#39;: column_definition.title,
                    &#39;content&#39;: value,
                }
            )

        row = Row(cells=prepared_data)
        self._rows.append(row)
        log.debug(&#39;Row: %s was added to Table&#39;, row)

    def save(self, force: bool = True) -&gt; None:
        &#34;&#34;&#34;Save all changes in the table

        Args:
            force: Force to update properties without digest check.

        Returns:

        &#34;&#34;&#34;
        super().save(force)

        row_requests: List[ChangeRowRequest] = []
        for row in self._rows:
            row_request = row.get_change_request()
            if row_request:
                row_requests.append(row_request)

        if not row_requests:
            return

        request = ChangeTableDataRequest(data=row_requests)
        api = SignalsNotebookApi.get_default_api()

        api.call(
            method=&#39;PATCH&#39;,
            path=(self._get_adt_endpoint(), self.eid),
            params={
                &#39;digest&#39;: None if force else self.digest,
                &#39;force&#39;: json.dumps(force),
            },
            data=request.json(exclude_none=True, by_alias=True),
        )

        self._reload_data()

    def get(self, value: Union[str, UUID], default: Any = None) -&gt; Union[Row, Any]:
        &#34;&#34;&#34;Get Row

        Args:
            value: name of id of Row
            default: default value if it doens&#39;t exist

        Returns:
            Union[Row, Any]
        &#34;&#34;&#34;
        try:
            return self[value]
        except KeyError:
            log.debug(&#39;KeyError were caught. Default value returned&#39;)
            return default

    def get_content(self, content_type: str = ContentType.CSV.value) -&gt; File:
        &#34;&#34;&#34;Get Table content

        Args:
            content_type: Export resource format

        Returns:

        &#34;&#34;&#34;
        self.ContentType(content_type)
        if content_type == self.ContentType.JSON.value:
            rows = []
            for item in self:
                row = {}
                for cell in item:
                    row[cell.name] = cell.content.dict()
                rows.append(row)
            return File(
                name=f&#39;{self.name}.json&#39;,
                content=json.dumps({&#39;data&#39;: rows}, default=str).encode(&#39;utf-8&#39;),
                content_type=content_type,
            )

        api = SignalsNotebookApi.get_default_api()
        log.debug(&#39;Get content for: %s| %s&#39;, self.__class__.__name__, self.eid)

        response = api.call(
            method=&#39;GET&#39;,
            path=(self._get_endpoint(), self.eid, &#39;export&#39;),
            params={
                &#39;format&#39;: None,
            },
        )

        content_disposition = response.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
        _, params = cgi.parse_header(content_disposition)

        return File(
            name=params[&#39;filename&#39;],
            content=response.content,
            content_type=response.headers.get(&#39;content-type&#39;),
        )

    @classmethod
    def create(
        cls,
        *,
        container: Container,
        name: str,
        content: List[Dict[str, CellContentDict]] = None,
        template: str = None,
        digest: str = None,
        force: bool = True,
    ) -&gt; Entity:
        &#34;&#34;&#34;Create Table Entity

        Args:
            container: Container where create new Table
            name: file name
            content: Table content
            template: template for table creation
            digest: Indicate digest of entity. It is used to avoid conflict while concurrent editing.
            force: Force to post attachment

        Returns:
            Table
        &#34;&#34;&#34;
        log.debug(&#39;Create Table: %s...&#39;, cls.__name__)
        if template:
            api = SignalsNotebookApi.get_default_api()
            request = {
                &#39;data&#39;: {
                    &#39;type&#39;: EntityType.GRID,
                    &#39;attributes&#39;: {&#39;name&#39;: name},
                    &#39;relationships&#39;: {
                        &#39;ancestors&#39;: {&#39;data&#39;: [{&#39;type&#39;: EntityType.EXPERIMENT, &#39;id&#39;: container.eid}]},
                        &#39;template&#39;: {&#39;data&#39;: {&#39;type&#39;: EntityType.GRID, &#39;id&#39;: template}},
                    },
                }
            }

            response = api.call(
                method=&#39;POST&#39;,
                path=(cls._get_endpoint(),),
                params={
                    &#39;digest&#39;: digest,
                    &#39;force&#39;: json.dumps(force),
                },
                json=request,
            )
            result = TableResponse(**response.json())
            table = cast(ResponseData, result.data).body
            log.debug(&#39;Entity: %s was created.&#39;, cls.__name__)
            if content:
                for row in content:
                    table.add_row(row)
                table.save()
            return table

        log.debug(&#39;There is no needful template. Table will be uploaded as *.csv File...&#39;)
        log.debug(&#39;Create table: %s with name: %s in Container: %s&#39;, cls.__name__, name, container.eid)
        return container.add_child(
            name=name,
            content=json.dumps({&#39;data&#39;: content}, default=str).encode(&#39;utf-8&#39;),
            content_type=cls.ContentType.JSON,
            force=force,
        )

    def get_html(self) -&gt; str:
        &#34;&#34;&#34;Get in HTML format

        Returns:
            Rendered template as a string
        &#34;&#34;&#34;

        rows = []
        column_definitions = self.get_column_definitions_list()

        table_head = []
        for column_definition in column_definitions:
            table_head.append(column_definition.title)

        for row in self:
            reformatted_row = {}

            for column_definition in column_definitions:
                cell = cast(Row, row).get(column_definition.key, None)
                cell = cast(Cell, cell)
                reformatted_row[column_definition.title] = &#39;&#39; if cell is None else (cell.display or cell.value)

            rows.append(reformatted_row)

        template = env.get_template(self._template_name)
        log.info(&#39;Html template for %s:%s has been rendered.&#39;, self.__class__.__name__, self.eid)

        return template.render(name=self.name, table_head=table_head, rows=rows)

    def dump(self, base_path: str, fs_handler: FSHandler) -&gt; None:  # type: ignore[override]
        &#34;&#34;&#34;Dump Table entity

        Args:
            base_path: content path where create dump
            fs_handler: FSHandler

        Returns:

        &#34;&#34;&#34;
        log.debug(&#39;Dumping table: %s with name: %s...&#39;, self.eid, self.name)

        content = self.get_content(content_type=self.ContentType.JSON)
        column_definitions = self.get_column_definitions_list()

        metadata = {
            &#39;file_name&#39;: content.name,
            &#39;content_type&#39;: content.content_type,
            &#39;columns&#39;: [item.title for item in column_definitions],
            **{k: v for k, v in self.dict().items() if k in (&#39;name&#39;, &#39;description&#39;, &#39;eid&#39;)},
        }
        fs_handler.write(fs_handler.join_path(base_path, self.eid, &#39;metadata.json&#39;), json.dumps(metadata, default=str))
        file_name = content.name
        data = content.content
        fs_handler.write(fs_handler.join_path(base_path, self.eid, file_name), data)
        log.debug(&#39;Table: %s was dumped successfully&#39;, self.eid, self.name)

    @classmethod
    def load(cls, path: str, fs_handler: FSHandler, parent: Container) -&gt; None:  # type: ignore[override]
        &#34;&#34;&#34;Load Table entity

        Args:
            path: content path
            fs_handler: FSHandler
            parent: Container where load Table entity

        Returns:

        &#34;&#34;&#34;
        log.debug(&#39;Loading table from dump...&#39;)
        metadata_path = fs_handler.join_path(path, &#39;metadata.json&#39;)
        metadata = json.loads(fs_handler.read(metadata_path))
        content_path = fs_handler.join_path(path, metadata[&#39;file_name&#39;])
        content_bytes = fs_handler.read(content_path)
        content = json.loads(content_bytes)
        rows = content[&#39;data&#39;]
        column_definitions = metadata.get(&#39;columns&#39;)
        templates = EntityStore.get_list(
            include_types=[EntityType.GRID], include_options=[EntityStore.IncludeOptions.TEMPLATE]
        )

        file_creation = True
        for item in templates:
            template = cast(&#39;Table&#39;, item)
            template_column_definitions = template.get_column_definitions_list()
            template_columns = [item.title for item in template_column_definitions]
            if set(template_columns) == set(column_definitions):
                file_creation = False
                cls.create(
                    container=parent,
                    name=metadata[&#39;name&#39;],
                    template=template.eid,
                    content=rows,
                )
                break

        if file_creation:
            cls.create(container=parent, name=metadata[&#39;name&#39;], content=rows, force=True)
        log.debug(&#39;Table was loaded to Container: %s&#39;, parent.eid)

    @classmethod
    def dump_templates(cls, base_path: str, fs_handler: FSHandler) -&gt; None:
        &#34;&#34;&#34;Dump Table templates

        Args:
            base_path: content path where create templates dump
            fs_handler: FSHandler

        Returns:

        &#34;&#34;&#34;
        from signals_notebook.entities import EntityStore

        entity_type = cls._get_entity_type()

        templates = EntityStore.get_list(
            include_types=[entity_type], include_options=[EntityStore.IncludeOptions.TEMPLATE]
        )

        try:
            for item in templates:
                template = cast(&#39;Table&#39;, item)
                content = template.get_content(content_type=cls.ContentType.JSON)
                column_definitions = template.get_column_definitions_list()
                metadata = {
                    &#39;file_name&#39;: content.name,
                    &#39;content_type&#39;: content.content_type,
                    &#39;columns&#39;: [item.title for item in column_definitions],
                    **{k: v for k, v in template.dict().items() if k in (&#39;name&#39;, &#39;description&#39;, &#39;eid&#39;)},
                }
                fs_handler.write(
                    fs_handler.join_path(base_path, &#39;templates&#39;, entity_type, f&#39;metadata_{template.name}.json&#39;),
                    json.dumps(metadata),
                )
        except TypeError:
            pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.entity.Entity" href="../entity.html#signals_notebook.entities.entity.Entity">Entity</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.Table.ContentType"><code class="name">var <span class="ident">ContentType</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.type"><code class="name">var <span class="ident">type</span> : Literal[<EntityType.GRID: 'grid'>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.Table.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>*, container: <a title="signals_notebook.entities.container.Container" href="../container.html#signals_notebook.entities.container.Container">Container</a>, name: str, content: List[Dict[str, <a title="signals_notebook.entities.tables.cell.CellContentDict" href="cell.html#signals_notebook.entities.tables.cell.CellContentDict">CellContentDict</a>]] = None, template: str = None, digest: str = None, force: bool = True) ‑> <a title="signals_notebook.entities.entity.Entity" href="../entity.html#signals_notebook.entities.entity.Entity">Entity</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create Table Entity</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>container</code></strong></dt>
<dd>Container where create new Table</dd>
<dt><strong><code>name</code></strong></dt>
<dd>file name</dd>
<dt><strong><code>content</code></strong></dt>
<dd>Table content</dd>
<dt><strong><code>template</code></strong></dt>
<dd>template for table creation</dd>
<dt><strong><code>digest</code></strong></dt>
<dd>Indicate digest of entity. It is used to avoid conflict while concurrent editing.</dd>
<dt><strong><code>force</code></strong></dt>
<dd>Force to post attachment</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create(
    cls,
    *,
    container: Container,
    name: str,
    content: List[Dict[str, CellContentDict]] = None,
    template: str = None,
    digest: str = None,
    force: bool = True,
) -&gt; Entity:
    &#34;&#34;&#34;Create Table Entity

    Args:
        container: Container where create new Table
        name: file name
        content: Table content
        template: template for table creation
        digest: Indicate digest of entity. It is used to avoid conflict while concurrent editing.
        force: Force to post attachment

    Returns:
        Table
    &#34;&#34;&#34;
    log.debug(&#39;Create Table: %s...&#39;, cls.__name__)
    if template:
        api = SignalsNotebookApi.get_default_api()
        request = {
            &#39;data&#39;: {
                &#39;type&#39;: EntityType.GRID,
                &#39;attributes&#39;: {&#39;name&#39;: name},
                &#39;relationships&#39;: {
                    &#39;ancestors&#39;: {&#39;data&#39;: [{&#39;type&#39;: EntityType.EXPERIMENT, &#39;id&#39;: container.eid}]},
                    &#39;template&#39;: {&#39;data&#39;: {&#39;type&#39;: EntityType.GRID, &#39;id&#39;: template}},
                },
            }
        }

        response = api.call(
            method=&#39;POST&#39;,
            path=(cls._get_endpoint(),),
            params={
                &#39;digest&#39;: digest,
                &#39;force&#39;: json.dumps(force),
            },
            json=request,
        )
        result = TableResponse(**response.json())
        table = cast(ResponseData, result.data).body
        log.debug(&#39;Entity: %s was created.&#39;, cls.__name__)
        if content:
            for row in content:
                table.add_row(row)
            table.save()
        return table

    log.debug(&#39;There is no needful template. Table will be uploaded as *.csv File...&#39;)
    log.debug(&#39;Create table: %s with name: %s in Container: %s&#39;, cls.__name__, name, container.eid)
    return container.add_child(
        name=name,
        content=json.dumps({&#39;data&#39;: content}, default=str).encode(&#39;utf-8&#39;),
        content_type=cls.ContentType.JSON,
        force=force,
    )</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.dump_templates"><code class="name flex">
<span>def <span class="ident">dump_templates</span></span>(<span>base_path: str, fs_handler: <a title="signals_notebook.utils.fs_handler.FSHandler" href="../../utils/fs_handler.html#signals_notebook.utils.fs_handler.FSHandler">FSHandler</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dump Table templates</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_path</code></strong></dt>
<dd>content path where create templates dump</dd>
<dt><strong><code>fs_handler</code></strong></dt>
<dd>FSHandler</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def dump_templates(cls, base_path: str, fs_handler: FSHandler) -&gt; None:
    &#34;&#34;&#34;Dump Table templates

    Args:
        base_path: content path where create templates dump
        fs_handler: FSHandler

    Returns:

    &#34;&#34;&#34;
    from signals_notebook.entities import EntityStore

    entity_type = cls._get_entity_type()

    templates = EntityStore.get_list(
        include_types=[entity_type], include_options=[EntityStore.IncludeOptions.TEMPLATE]
    )

    try:
        for item in templates:
            template = cast(&#39;Table&#39;, item)
            content = template.get_content(content_type=cls.ContentType.JSON)
            column_definitions = template.get_column_definitions_list()
            metadata = {
                &#39;file_name&#39;: content.name,
                &#39;content_type&#39;: content.content_type,
                &#39;columns&#39;: [item.title for item in column_definitions],
                **{k: v for k, v in template.dict().items() if k in (&#39;name&#39;, &#39;description&#39;, &#39;eid&#39;)},
            }
            fs_handler.write(
                fs_handler.join_path(base_path, &#39;templates&#39;, entity_type, f&#39;metadata_{template.name}.json&#39;),
                json.dumps(metadata),
            )
    except TypeError:
        pass</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>path: str, fs_handler: <a title="signals_notebook.utils.fs_handler.FSHandler" href="../../utils/fs_handler.html#signals_notebook.utils.fs_handler.FSHandler">FSHandler</a>, parent: <a title="signals_notebook.entities.container.Container" href="../container.html#signals_notebook.entities.container.Container">Container</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load Table entity</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>content path</dd>
<dt><strong><code>fs_handler</code></strong></dt>
<dd>FSHandler</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>Container where load Table entity</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, path: str, fs_handler: FSHandler, parent: Container) -&gt; None:  # type: ignore[override]
    &#34;&#34;&#34;Load Table entity

    Args:
        path: content path
        fs_handler: FSHandler
        parent: Container where load Table entity

    Returns:

    &#34;&#34;&#34;
    log.debug(&#39;Loading table from dump...&#39;)
    metadata_path = fs_handler.join_path(path, &#39;metadata.json&#39;)
    metadata = json.loads(fs_handler.read(metadata_path))
    content_path = fs_handler.join_path(path, metadata[&#39;file_name&#39;])
    content_bytes = fs_handler.read(content_path)
    content = json.loads(content_bytes)
    rows = content[&#39;data&#39;]
    column_definitions = metadata.get(&#39;columns&#39;)
    templates = EntityStore.get_list(
        include_types=[EntityType.GRID], include_options=[EntityStore.IncludeOptions.TEMPLATE]
    )

    file_creation = True
    for item in templates:
        template = cast(&#39;Table&#39;, item)
        template_column_definitions = template.get_column_definitions_list()
        template_columns = [item.title for item in template_column_definitions]
        if set(template_columns) == set(column_definitions):
            file_creation = False
            cls.create(
                container=parent,
                name=metadata[&#39;name&#39;],
                template=template.eid,
                content=rows,
            )
            break

    if file_creation:
        cls.create(container=parent, name=metadata[&#39;name&#39;], content=rows, force=True)
    log.debug(&#39;Table was loaded to Container: %s&#39;, parent.eid)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.Table.add_row"><code class="name flex">
<span>def <span class="ident">add_row</span></span>(<span>self, data: Dict[str, <a title="signals_notebook.entities.tables.cell.CellContentDict" href="cell.html#signals_notebook.entities.tables.cell.CellContentDict">CellContentDict</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add row in the table</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Cells to add in the row</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_row(self, data: Dict[str, CellContentDict]) -&gt; None:
    &#34;&#34;&#34;Add row in the table

    Args:
        data: Cells to add in the row

    Returns:

    &#34;&#34;&#34;
    column_definitions_map = self.get_column_definitions_map()

    prepared_data: List[Dict[str, Any]] = []
    for key, value in data.items():
        column_definition = column_definitions_map.get(key)
        if not column_definition:
            continue

        prepared_data.append(
            {
                &#39;key&#39;: column_definition.key,
                &#39;type&#39;: column_definition.type,
                &#39;name&#39;: column_definition.title,
                &#39;content&#39;: value,
            }
        )

    row = Row(cells=prepared_data)
    self._rows.append(row)
    log.debug(&#39;Row: %s was added to Table&#39;, row)</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.as_dataframe"><code class="name flex">
<span>def <span class="ident">as_dataframe</span></span>(<span>self, use_labels: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Get as data table</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_labels</code></strong></dt>
<dd>use cells names</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pd.DataFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dataframe(self, use_labels: bool = True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get as data table

    Args:
        use_labels: use cells names

    Returns:
        pd.DataFrame
    &#34;&#34;&#34;
    if not self._rows:
        self._reload_data()

    data = []
    index = []
    for row in self._rows:
        index.append(row.id)
        data.append(row.get_values(use_labels))

    return pd.DataFrame(data=data, index=index)</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.as_raw_data"><code class="name flex">
<span>def <span class="ident">as_raw_data</span></span>(<span>self, use_labels: bool = True) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get as a list of dictionaries</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_labels</code></strong></dt>
<dd>use cels names</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_raw_data(self, use_labels: bool = True) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Get as a list of dictionaries

    Args:
        use_labels: use cels names

    Returns:

    &#34;&#34;&#34;
    if not self._rows:
        self._reload_data()

    data = []
    for row in self._rows:
        data.append(row.get_values(use_labels))

    return data</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.delete_row_by_id"><code class="name flex">
<span>def <span class="ident">delete_row_by_id</span></span>(<span>self, row_id: Union[uuid.UUID, str], digest: str = None, force: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>row_id</code></strong></dt>
<dd>id of the row</dd>
<dt><strong><code>digest</code></strong></dt>
<dd>Indicate digest of entity. It is used to avoid conflict while concurrent editing.</dd>
<dt>If the parameter 'force' is true, this parameter is optional.</dt>
<dt>If the parameter 'force' is false, this parameter is required.</dt>
<dt><strong><code>force</code></strong></dt>
<dd>Force to update properties without digest check.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_row_by_id(self, row_id: Union[str, UUID], digest: str = None, force: bool = True) -&gt; None:
    &#34;&#34;&#34;

    Args:
        row_id: id of the row
        digest: Indicate digest of entity. It is used to avoid conflict while concurrent editing.
        If the parameter &#39;force&#39; is true, this parameter is optional.
        If the parameter &#39;force&#39; is false, this parameter is required.
        force: Force to update properties without digest check.

    Returns:

    &#34;&#34;&#34;
    if isinstance(row_id, UUID):
        _row_id = row_id.hex
    else:
        _row_id = row_id

    api = SignalsNotebookApi.get_default_api()

    api.call(
        method=&#39;DELETE&#39;,
        path=(self._get_adt_endpoint(), self.eid, _row_id),
        params={
            &#39;digest&#39;: digest,
            &#39;force&#39;: json.dumps(force),
        },
    )

    log.debug(&#39;Row %s was deleted&#39;, row_id)
    self._reload_data()</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self, base_path: str, fs_handler: <a title="signals_notebook.utils.fs_handler.FSHandler" href="../../utils/fs_handler.html#signals_notebook.utils.fs_handler.FSHandler">FSHandler</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dump Table entity</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_path</code></strong></dt>
<dd>content path where create dump</dd>
<dt><strong><code>fs_handler</code></strong></dt>
<dd>FSHandler</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self, base_path: str, fs_handler: FSHandler) -&gt; None:  # type: ignore[override]
    &#34;&#34;&#34;Dump Table entity

    Args:
        base_path: content path where create dump
        fs_handler: FSHandler

    Returns:

    &#34;&#34;&#34;
    log.debug(&#39;Dumping table: %s with name: %s...&#39;, self.eid, self.name)

    content = self.get_content(content_type=self.ContentType.JSON)
    column_definitions = self.get_column_definitions_list()

    metadata = {
        &#39;file_name&#39;: content.name,
        &#39;content_type&#39;: content.content_type,
        &#39;columns&#39;: [item.title for item in column_definitions],
        **{k: v for k, v in self.dict().items() if k in (&#39;name&#39;, &#39;description&#39;, &#39;eid&#39;)},
    }
    fs_handler.write(fs_handler.join_path(base_path, self.eid, &#39;metadata.json&#39;), json.dumps(metadata, default=str))
    file_name = content.name
    data = content.content
    fs_handler.write(fs_handler.join_path(base_path, self.eid, file_name), data)
    log.debug(&#39;Table: %s was dumped successfully&#39;, self.eid, self.name)</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, value: Union[uuid.UUID, str], default: Any = None) ‑> Union[<a title="signals_notebook.entities.tables.row.Row" href="row.html#signals_notebook.entities.tables.row.Row">Row</a>, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Get Row</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>name of id of Row</dd>
<dt><strong><code>default</code></strong></dt>
<dd>default value if it doens't exist</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Union[Row, Any]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, value: Union[str, UUID], default: Any = None) -&gt; Union[Row, Any]:
    &#34;&#34;&#34;Get Row

    Args:
        value: name of id of Row
        default: default value if it doens&#39;t exist

    Returns:
        Union[Row, Any]
    &#34;&#34;&#34;
    try:
        return self[value]
    except KeyError:
        log.debug(&#39;KeyError were caught. Default value returned&#39;)
        return default</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.get_column_definitions_list"><code class="name flex">
<span>def <span class="ident">get_column_definitions_list</span></span>(<span>self) ‑> List[Union[<a title="signals_notebook.entities.tables.cell.AttributeListColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.AttributeListColumnDefinition">AttributeListColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.AutotextListColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.AutotextListColumnDefinition">AutotextListColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.ListColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.ListColumnDefinition">ListColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.MultiSelectColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.MultiSelectColumnDefinition">MultiSelectColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.UnitColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.UnitColumnDefinition">UnitColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.ColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.ColumnDefinition">ColumnDefinition</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch column definitions</p>
<h2 id="returns">Returns</h2>
<p>List[GenericColumnDefinition]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_definitions_list(self) -&gt; List[GenericColumnDefinition]:
    &#34;&#34;&#34;Fetch column definitions

    Returns:
        List[GenericColumnDefinition]
    &#34;&#34;&#34;
    api = SignalsNotebookApi.get_default_api()

    response = api.call(method=&#39;GET&#39;, path=(self._get_adt_endpoint(), self.eid, &#39;_column&#39;))

    result = ColumnDefinitionsResponse(**response.json())

    return cast(ResponseData, result.data).body.columns</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.get_column_definitions_map"><code class="name flex">
<span>def <span class="ident">get_column_definitions_map</span></span>(<span>self) ‑> Dict[str, Union[<a title="signals_notebook.entities.tables.cell.AttributeListColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.AttributeListColumnDefinition">AttributeListColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.AutotextListColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.AutotextListColumnDefinition">AutotextListColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.ListColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.ListColumnDefinition">ListColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.MultiSelectColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.MultiSelectColumnDefinition">MultiSelectColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.UnitColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.UnitColumnDefinition">UnitColumnDefinition</a>, <a title="signals_notebook.entities.tables.cell.ColumnDefinition" href="cell.html#signals_notebook.entities.tables.cell.ColumnDefinition">ColumnDefinition</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get column definitions as a dictionary</p>
<h2 id="returns">Returns</h2>
<p>Dict[str, GenericColumnDefinition]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_definitions_map(self) -&gt; Dict[str, GenericColumnDefinition]:
    &#34;&#34;&#34;Get column definitions as a dictionary

    Returns:
        Dict[str, GenericColumnDefinition]
    &#34;&#34;&#34;
    column_definitions = self.get_column_definitions_list()
    column_definitions_map: Dict[str, GenericColumnDefinition] = {}

    for column_definition in column_definitions:
        column_definitions_map[str(column_definition.key)] = column_definition
        column_definitions_map[column_definition.title] = column_definition

    return column_definitions_map</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.get_content"><code class="name flex">
<span>def <span class="ident">get_content</span></span>(<span>self, content_type: str = 'text/csv') ‑> <a title="signals_notebook.common_types.File" href="../../common_types.html#signals_notebook.common_types.File">File</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get Table content</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>content_type</code></strong></dt>
<dd>Export resource format</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content(self, content_type: str = ContentType.CSV.value) -&gt; File:
    &#34;&#34;&#34;Get Table content

    Args:
        content_type: Export resource format

    Returns:

    &#34;&#34;&#34;
    self.ContentType(content_type)
    if content_type == self.ContentType.JSON.value:
        rows = []
        for item in self:
            row = {}
            for cell in item:
                row[cell.name] = cell.content.dict()
            rows.append(row)
        return File(
            name=f&#39;{self.name}.json&#39;,
            content=json.dumps({&#39;data&#39;: rows}, default=str).encode(&#39;utf-8&#39;),
            content_type=content_type,
        )

    api = SignalsNotebookApi.get_default_api()
    log.debug(&#39;Get content for: %s| %s&#39;, self.__class__.__name__, self.eid)

    response = api.call(
        method=&#39;GET&#39;,
        path=(self._get_endpoint(), self.eid, &#39;export&#39;),
        params={
            &#39;format&#39;: None,
        },
    )

    content_disposition = response.headers.get(&#39;content-disposition&#39;, &#39;&#39;)
    _, params = cgi.parse_header(content_disposition)

    return File(
        name=params[&#39;filename&#39;],
        content=response.content,
        content_type=response.headers.get(&#39;content-type&#39;),
    )</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.get_html"><code class="name flex">
<span>def <span class="ident">get_html</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get in HTML format</p>
<h2 id="returns">Returns</h2>
<p>Rendered template as a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_html(self) -&gt; str:
    &#34;&#34;&#34;Get in HTML format

    Returns:
        Rendered template as a string
    &#34;&#34;&#34;

    rows = []
    column_definitions = self.get_column_definitions_list()

    table_head = []
    for column_definition in column_definitions:
        table_head.append(column_definition.title)

    for row in self:
        reformatted_row = {}

        for column_definition in column_definitions:
            cell = cast(Row, row).get(column_definition.key, None)
            cell = cast(Cell, cell)
            reformatted_row[column_definition.title] = &#39;&#39; if cell is None else (cell.display or cell.value)

        rows.append(reformatted_row)

    template = env.get_template(self._template_name)
    log.info(&#39;Html template for %s:%s has been rendered.&#39;, self.__class__.__name__, self.eid)

    return template.render(name=self.name, table_head=table_head, rows=rows)</code></pre>
</details>
</dd>
<dt id="signals_notebook.entities.tables.table.Table.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, force: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Save all changes in the table</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force</code></strong></dt>
<dd>Force to update properties without digest check.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, force: bool = True) -&gt; None:
    &#34;&#34;&#34;Save all changes in the table

    Args:
        force: Force to update properties without digest check.

    Returns:

    &#34;&#34;&#34;
    super().save(force)

    row_requests: List[ChangeRowRequest] = []
    for row in self._rows:
        row_request = row.get_change_request()
        if row_request:
            row_requests.append(row_request)

    if not row_requests:
        return

    request = ChangeTableDataRequest(data=row_requests)
    api = SignalsNotebookApi.get_default_api()

    api.call(
        method=&#39;PATCH&#39;,
        path=(self._get_adt_endpoint(), self.eid),
        params={
            &#39;digest&#39;: None if force else self.digest,
            &#39;force&#39;: json.dumps(force),
        },
        data=request.json(exclude_none=True, by_alias=True),
    )

    self._reload_data()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="signals_notebook.entities.entity.Entity" href="../entity.html#signals_notebook.entities.entity.Entity">Entity</a></b></code>:
<ul class="hlist">
<li><code><a title="signals_notebook.entities.entity.Entity.delete" href="../entity.html#signals_notebook.entities.entity.Entity.delete">delete</a></code></li>
<li><code><a title="signals_notebook.entities.entity.Entity.get_list" href="../entity.html#signals_notebook.entities.entity.Entity.get_list">get_list</a></code></li>
<li><code><a title="signals_notebook.entities.entity.Entity.get_subclasses" href="../entity.html#signals_notebook.entities.entity.Entity.get_subclasses">get_subclasses</a></code></li>
<li><code><a title="signals_notebook.entities.entity.Entity.get_template_name" href="../entity.html#signals_notebook.entities.entity.Entity.get_template_name">get_template_name</a></code></li>
<li><code><a title="signals_notebook.entities.entity.Entity.refresh" href="../entity.html#signals_notebook.entities.entity.Entity.refresh">refresh</a></code></li>
<li><code><a title="signals_notebook.entities.entity.Entity.set_template_name" href="../entity.html#signals_notebook.entities.entity.Entity.set_template_name">set_template_name</a></code></li>
<li><code><a title="signals_notebook.entities.entity.Entity.short_description" href="../entity.html#signals_notebook.entities.entity.Entity.short_description">short_description</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="signals_notebook.entities.tables.table.TableDataResponse"><code class="flex name class">
<span>class <span class="ident">TableDataResponse</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableDataResponse(Response[Row]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.Response[Row]" href="#signals_notebook.entities.tables.table.Response[Row]">Response[Row]</a></li>
<li><a title="signals_notebook.common_types.Response" href="../../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.TableDataResponse.data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[Row], List[pydantic.generics.ResponseData[Row]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.TableDataResponse.links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="signals_notebook.entities.tables.table.TableResponse"><code class="flex name class">
<span>class <span class="ident">TableResponse</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableResponse(Response[Table]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="signals_notebook.entities.tables.table.Response[Table]" href="#signals_notebook.entities.tables.table.Response[Table]">Response[Table]</a></li>
<li><a title="signals_notebook.common_types.Response" href="../../common_types.html#signals_notebook.common_types.Response">Response</a></li>
<li>pydantic.generics.GenericModel</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="signals_notebook.entities.tables.table.TableResponse.data"><code class="name">var <span class="ident">data</span> : Union[pydantic.generics.ResponseData[<a title="signals_notebook.entities.tables.table.Table" href="#signals_notebook.entities.tables.table.Table">Table</a>], List[pydantic.generics.ResponseData[<a title="signals_notebook.entities.tables.table.Table" href="#signals_notebook.entities.tables.table.Table">Table</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="signals_notebook.entities.tables.table.TableResponse.links"><code class="name">var <span class="ident">links</span> : Optional[<a title="signals_notebook.common_types.Links" href="../../common_types.html#signals_notebook.common_types.Links">Links</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="signals_notebook.entities.tables" href="index.html">signals_notebook.entities.tables</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.ChangeTableDataRequest" href="#signals_notebook.entities.tables.table.ChangeTableDataRequest">ChangeTableDataRequest</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.ChangeTableDataRequest.data" href="#signals_notebook.entities.tables.table.ChangeTableDataRequest.data">data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.ColumnDefinitionsResponse" href="#signals_notebook.entities.tables.table.ColumnDefinitionsResponse">ColumnDefinitionsResponse</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.ColumnDefinitionsResponse.data" href="#signals_notebook.entities.tables.table.ColumnDefinitionsResponse.data">data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.ColumnDefinitionsResponse.links" href="#signals_notebook.entities.tables.table.ColumnDefinitionsResponse.links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.DataList[ChangeRowRequest]" href="#signals_notebook.entities.tables.table.DataList[ChangeRowRequest]">DataList[ChangeRowRequest]</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.DataList[ChangeRowRequest].Config" href="#signals_notebook.entities.tables.table.DataList[ChangeRowRequest].Config">Config</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.DataList[ChangeRowRequest].data" href="#signals_notebook.entities.tables.table.DataList[ChangeRowRequest].data">data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.Response[ColumnDefinitions]" href="#signals_notebook.entities.tables.table.Response[ColumnDefinitions]">Response[ColumnDefinitions]</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.Response[ColumnDefinitions].Config" href="#signals_notebook.entities.tables.table.Response[ColumnDefinitions].Config">Config</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Response[ColumnDefinitions].data" href="#signals_notebook.entities.tables.table.Response[ColumnDefinitions].data">data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Response[ColumnDefinitions].links" href="#signals_notebook.entities.tables.table.Response[ColumnDefinitions].links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.Response[Row]" href="#signals_notebook.entities.tables.table.Response[Row]">Response[Row]</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.Response[Row].Config" href="#signals_notebook.entities.tables.table.Response[Row].Config">Config</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Response[Row].data" href="#signals_notebook.entities.tables.table.Response[Row].data">data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Response[Row].links" href="#signals_notebook.entities.tables.table.Response[Row].links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.Response[Table]" href="#signals_notebook.entities.tables.table.Response[Table]">Response[Table]</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.Response[Table].Config" href="#signals_notebook.entities.tables.table.Response[Table].Config">Config</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Response[Table].data" href="#signals_notebook.entities.tables.table.Response[Table].data">data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Response[Table].links" href="#signals_notebook.entities.tables.table.Response[Table].links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.Table" href="#signals_notebook.entities.tables.table.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.Table.ContentType" href="#signals_notebook.entities.tables.table.Table.ContentType">ContentType</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.add_row" href="#signals_notebook.entities.tables.table.Table.add_row">add_row</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.as_dataframe" href="#signals_notebook.entities.tables.table.Table.as_dataframe">as_dataframe</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.as_raw_data" href="#signals_notebook.entities.tables.table.Table.as_raw_data">as_raw_data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.create" href="#signals_notebook.entities.tables.table.Table.create">create</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.delete_row_by_id" href="#signals_notebook.entities.tables.table.Table.delete_row_by_id">delete_row_by_id</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.dump" href="#signals_notebook.entities.tables.table.Table.dump">dump</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.dump_templates" href="#signals_notebook.entities.tables.table.Table.dump_templates">dump_templates</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.get" href="#signals_notebook.entities.tables.table.Table.get">get</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.get_column_definitions_list" href="#signals_notebook.entities.tables.table.Table.get_column_definitions_list">get_column_definitions_list</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.get_column_definitions_map" href="#signals_notebook.entities.tables.table.Table.get_column_definitions_map">get_column_definitions_map</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.get_content" href="#signals_notebook.entities.tables.table.Table.get_content">get_content</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.get_html" href="#signals_notebook.entities.tables.table.Table.get_html">get_html</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.load" href="#signals_notebook.entities.tables.table.Table.load">load</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.save" href="#signals_notebook.entities.tables.table.Table.save">save</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.Table.type" href="#signals_notebook.entities.tables.table.Table.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.TableDataResponse" href="#signals_notebook.entities.tables.table.TableDataResponse">TableDataResponse</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.TableDataResponse.data" href="#signals_notebook.entities.tables.table.TableDataResponse.data">data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.TableDataResponse.links" href="#signals_notebook.entities.tables.table.TableDataResponse.links">links</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="signals_notebook.entities.tables.table.TableResponse" href="#signals_notebook.entities.tables.table.TableResponse">TableResponse</a></code></h4>
<ul class="">
<li><code><a title="signals_notebook.entities.tables.table.TableResponse.data" href="#signals_notebook.entities.tables.table.TableResponse.data">data</a></code></li>
<li><code><a title="signals_notebook.entities.tables.table.TableResponse.links" href="#signals_notebook.entities.tables.table.TableResponse.links">links</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>